<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Open3D 教程学习指南 (持续整理) | Chase Blog</title><meta name=keywords content="Open3D"><meta name=description content="Open3D 是一个开源库，旨在为 3D 数据处理提供高效且易用的工具。它由 Intel 开发和维护，支持多种 3D 数据处理任务，如点云处理、3D 重建、几何处理和可视化等。"><meta name=author content="Chase"><link rel=canonical href=https://chase6305.github.io/posts/open3d/introduction/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://chase6305.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://chase6305.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://chase6305.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://chase6305.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://chase6305.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--code-block-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://chase6305.github.io/posts/open3d/introduction/"><meta property="og:site_name" content="Chase Blog"><meta property="og:title" content="Open3D 教程学习指南 (持续整理)"><meta property="og:description" content="Open3D 是一个开源库，旨在为 3D 数据处理提供高效且易用的工具。它由 Intel 开发和维护，支持多种 3D 数据处理任务，如点云处理、3D 重建、几何处理和可视化等。"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-04T00:00:00+00:00"><meta property="article:modified_time" content="2025-03-04T00:00:00+00:00"><meta property="article:tag" content="Open3D"><meta property="og:image" content="https://chase6305.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://chase6305.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Open3D 教程学习指南 (持续整理)"><meta name=twitter:description content="Open3D 是一个开源库，旨在为 3D 数据处理提供高效且易用的工具。它由 Intel 开发和维护，支持多种 3D 数据处理任务，如点云处理、3D 重建、几何处理和可视化等。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Open3D 教程学习指南 (持续整理)","item":"https://chase6305.github.io/posts/open3d/introduction/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Open3D 教程学习指南 (持续整理)","name":"Open3D 教程学习指南 (持续整理)","description":"Open3D 是一个开源库，旨在为 3D 数据处理提供高效且易用的工具。它由 Intel 开发和维护，支持多种 3D 数据处理任务，如点云处理、3D 重建、几何处理和可视化等。","keywords":["Open3D"],"articleBody":"本章仅为个人学习整理。\nOpen3D: https://www.open3d.org/ Github repo: https://github.com/isl-org/Open3D \n1. 概述 Open3D 是一个开源库，旨在为 3D 数据处理提供高效且易用的工具。它由 Intel 开发和维护，支持多种 3D 数据处理任务，如点云处理、3D 重建、几何处理和可视化等。\n1.1 主要功能  点云处理：  支持点云的读取、写入和可视化。 提供点云滤波、配准、分割和特征提取等功能。   3D 重建：  支持从深度图像生成 3D 网格。 提供多视图 3D 重建算法。   几何处理：  支持对三角网格、体素网格和曲面的处理。 提供几何变换、简化和布尔运算等功能。   可视化：  提供交互式的 3D 可视化工具。 支持点云、网格和体素的渲染。   机器学习：  提供与深度学习框架的集成，支持 3D 数据的机器学习任务。      2. 安装 2.1 安装 Open3D 方法一：通过 pip 安装 可以直接使用 pip 安装 Open3D：\npip install open3d 方法二：手动安装 你也可以从 PyPI 下载对应版本的 .whl 文件，然后手动安装。例如，对于 Linux x86 系统和 Python 3.9 环境：\npip install open3d-0.18.0-cp39-cp39-manylinux_2_27_x86_64.whl 方法三：安装 CPU 版本 如果不使用 NVIDIA 的 CUDA，可以考虑安装 CPU 版本：\npip install open3d-cpu 方法四：源码安装 你也可以从源码安装 Open3D。具体步骤可以参考 Open3D 的官方文档。\n2.2 第三方库管理 Open3D 使用 CMake 来管理第三方库。CMake 是一个跨平台的构建系统，它可以帮助自动化软件构建过程，包括查找和配置第三方库。Open3D 通过 CMake 的 find_package 和 ExternalProject 模块来管理第三方库。\n 第三方库管理步骤    查找系统库：\n Open3D 使用 find_package 命令查找系统中已经安装的库。例如，查找 Eigen 库： find_package(Eigen3 REQUIRED)include_directories(${EIGEN3_INCLUDE_DIR})    下载和构建外部项目：\n 对于一些没有预安装的库，Open3D 使用 ExternalProject_Add 命令从源代码下载并构建这些库。例如，下载并构建 GLFW： include(ExternalProject)ExternalProject_Add(glfw GIT_REPOSITORY https://github.com/glfw/glfw.git GIT_TAG latest CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=${CMAKE_BINARY_DIR}/third_party_install )    使用 third_party 目录：\n Open3D 在其源代码中包含了一些第三方库的副本，这些库存放在 third_party 目录下。CMakeLists.txt 文件会配置这些库的构建和链接。例如，配置和使用 Filament 库： add_subdirectory(third_party/filament)include_directories(third_party/filament/include)    Open3D 通过 CMake 的 find_package 和 ExternalProject_Add 命令来查找和管理第三方库，并使用 third_party 目录包含一些必要的库。这样可以确保在不同平台上都能顺利构建和运行 Open3D。\n2.3 编译原理   CMake 配置：\n Open3D 使用 CMake 作为构建系统。CMakeLists.txt 文件定义了项目的构建配置，包括源文件、依赖项、编译选项等。 CMake 会生成适合目标平台的构建文件（如 Makefile 或 Visual Studio 项目文件）。    依赖项管理：\n Open3D 依赖多个第三方库，如 Eigen（用于线性代数计算）、GLFW（用于窗口管理）、Pybind11（用于 Python 绑定）等。 CMake 会自动查找和配置这些依赖项。    编译和链接：\n CMake 生成的构建文件会调用编译器（如 GCC 或 Clang）编译源代码，并链接生成目标文件（如库或可执行文件）。 编译过程中会根据配置选项启用或禁用某些功能模块。    Python 绑定：\n 如果启用了 Python 绑定，Open3D 会使用 Pybind11 生成 Python 模块，使得 Open3D 可以在 Python 中使用。 编译过程中会生成 _pybind 模块，并将其安装到 Python 的包目录中。    3. 点云写入、读取、可视化 open3d.io.write_point_cloud 是一个用于将点云数据写入文件的函数。 open3d.io.read_point_cloud 是一个用于从文件中读取点云数据的函数。 open3d.visualization.draw_geometries 是一个用于可视化几何对象列表的函数。\n3.1 点云写入文件 open3d.io.write_point_cloud( filename: os.PathLike, pointcloud: open3d.geometry.PointCloud, format: str = 'auto', write_ascii: bool = False, compressed: bool = False, print_progress: bool = False ) - bool 参数说明 filename (os.PathLike)：文件路径。 pointcloud (open3d.geometry.PointCloud)：要写入的 PointCloud 对象。 format (str, optional, default='auto')：输出文件的格式。当未指定或设置为 auto 时，格式将从文件扩展名推断。 write_ascii (bool, optional, default=False)：如果为 True，则以 ASCII 格式输出，否则使用二进制格式。 compressed (bool, optional, default=False)：如果为 True，则以压缩格式写入。 print_progress (bool, optional, default=False)：如果为 True，在控制台中显示进度条。\n3.2 读取点云文件 open3d.io.read_point_cloud( filename: os.PathLike, format: str = 'auto', remove_nan_points: bool = False, remove_infinite_points: bool = False, print_progress: bool = False ) - open3d.geometry.PointCloud 参数说明 filename (os.PathLike)：文件路径。 format (str, optional, default='auto')：输入文件的格式。当未指定或设置为 auto 时，格式将从文件扩展名推断。 remove_nan_points (bool, optional, default=False)：如果为 True，则移除包含 NaN 值的点。 remove_infinite_points (bool, optional, default=False)：如果为 True，则移除包含无限值的点。 print_progress (bool, optional, default=False)：如果为 True，在控制台中显示进度条。\n3.3 可视化点云 open3d.visualization.draw_geometries( geometry_list: list[open3d.geometry.Geometry], window_name: str = 'Open3D', width: int = 1920, height: int = 1080, left: int = 50, top: int = 50, point_show_normal: bool = False, mesh_show_wireframe: bool = False, mesh_show_back_face: bool = False, lookat: numpy.ndarray[numpy.float64[3, 1]] | None = None, up: numpy.ndarray[numpy.float64[3, 1]] | None = None, front: numpy.ndarray[numpy.float64[3, 1]] | None = None, zoom: float | None = None ) - None 参数说明 geometry_list (list[open3d.geometry.Geometry])：要可视化的几何对象列表。 window_name (str, optional, default='Open3D')：可视化窗口的标题。 width (int, optional, default=1920)：可视化窗口的宽度。 height (int, optional, default=1080)：可视化窗口的高度。 left (int, optional, default=50)：可视化窗口的左边距。 top (int, optional, default=50)：可视化窗口的上边距。 point_show_normal (bool, optional, default=False)：如果为 True，则显示点的法线。 mesh_show_wireframe (bool, optional, default=False)：如果为 True，则显示网格的线框。 mesh_show_back_face (bool, optional, default=False)：如果为 True，则显示网格三角形的背面。 lookat (Optional[numpy.ndarray[numpy.float64[3, 1]]], optional, default=None)：相机的 lookat 向量。 up (Optional[numpy.ndarray[numpy.float64[3, 1]]], optional, default=None)：相机的 up 向量。 front (Optional[numpy.ndarray[numpy.float64[3, 1]]], optional, default=None)：相机的 front 向量。 zoom (Optional[float], optional, default=None)：相机的缩放。\n3.4 使用案例 import open3d as o3d import numpy as np # 生成一个简单的点云（例如，一个立方体的顶点） points = np.array([ [0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0], [0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1], ]) # 创建 PointCloud 对象 pcd = o3d.geometry.PointCloud() # 将点添加到 PointCloud 对象中 pcd.points = o3d.utility.Vector3dVector(points) # 保存点云到文件 o3d.io.write_point_cloud(\"generated_point_cloud.ply\", pcd) # 读取点云文件 load_pcd = o3d.io.read_point_cloud(\"generated_point_cloud.ply\") # 可视化点云 o3d.visualization.draw_geometries([load_pcd])   \n4. TriangleMesh 读取、保存 TriangleMeshIO节选代码: https://github.com/isl-org/Open3D/blob/main/cpp/open3d/io/TriangleMeshIO.cpp\nstatic const std::unordered_map std::string, std::functionbool(const std::string \u0026, geometry::TriangleMesh \u0026, const ReadTriangleMeshOptions \u0026) file_extension_to_trianglemesh_read_function{ {\"ply\", ReadTriangleMeshFromPLY}, {\"stl\", ReadTriangleMeshUsingASSIMP}, {\"obj\", ReadTriangleMeshUsingASSIMP}, {\"off\", ReadTriangleMeshFromOFF}, {\"gltf\", ReadTriangleMeshUsingASSIMP}, {\"glb\", ReadTriangleMeshUsingASSIMP}, {\"fbx\", ReadTriangleMeshUsingASSIMP}, }; static const std::unordered_map std::string, std::functionbool(const std::string \u0026, const geometry::TriangleMesh \u0026, const bool, const bool, const bool, const bool, const bool, const bool) file_extension_to_trianglemesh_write_function{ {\"ply\", WriteTriangleMeshToPLY}, {\"stl\", WriteTriangleMeshToSTL}, {\"obj\", WriteTriangleMeshToOBJ}, {\"off\", WriteTriangleMeshToOFF}, {\"gltf\", WriteTriangleMeshToGLTF}, {\"glb\", WriteTriangleMeshToGLTF}, }; } // unnamed namespace 在这段代码中，open3d 使用 assimp 来读取和写入多种三角网格文件格式。以下是支持的文件格式：\n4.1 支持的读取文件格式  ply (使用 ReadTriangleMeshFromPLY 函数) stl (使用 ReadTriangleMeshUsingASSIMP 函数) obj (使用 ReadTriangleMeshUsingASSIMP 函数) off (使用 ReadTriangleMeshFromOFF 函数) gltf (使用 ReadTriangleMeshUsingASSIMP 函数) glb (使用 ReadTriangleMeshUsingASSIMP 函数) fbx (使用 ReadTriangleMeshUsingASSIMP 函数)  4.2 支持的写入文件格式  ply (使用 WriteTriangleMeshToPLY 函数) stl (使用 WriteTriangleMeshToSTL 函数) obj (使用 WriteTriangleMeshToOBJ 函数) off (使用 WriteTriangleMeshToOFF 函数) gltf (使用 WriteTriangleMeshToGLTF 函数) glb (使用 WriteTriangleMeshToGLTF 函数)  这些函数通过文件扩展名与相应的读取和写入函数进行映射，从而支持多种三角网格文件格式的读写操作。\n4.3 TriangleMesh 读取 open3d.io.read_triangle_mesh\nopen3d.io.read_triangle_mesh( filename: os.PathLike, enable_post_processing: bool = False, print_progress: bool = False ) → open3d.geometry.TriangleMesh 参数说明 filename：文件路径，类型为 os.PathLike。 enable_post_processing：是否启用后处理，类型为 bool，默认值为 False。 print_progress：是否在控制台显示进度条，类型为 bool，默认值为 False。\n  \nimport open3d as o3d # 定义文件路径 filename = \"doll.stl\" try: # 尝试读取三角网格 mesh = o3d.io.read_triangle_mesh(filename, enable_post_processing=True, print_progress=True) # 检查网格是否成功读取 if mesh.is_empty(): print(\"Failed to read the mesh. The file format may not be supported.\") else: print(\"Successfully read the mesh.\") # 可视化三角网格 o3d.visualization.draw_geometries([mesh]) except Exception as e: print(f\"An error occurred: {e}\")    此时因为没有计算法线, 可视化出来的模型会涂成统一的灰色 然后我们可以compute_vertex_normals来计算出法线信息\nimport open3d as o3d import numpy as np # 定义文件路径 filename = \"doll.stl\" # 读取三角网格 mesh = o3d.io.read_triangle_mesh(filename, enable_post_processing=True, print_progress=True) # 检查网格是否成功读取 if mesh.is_empty(): print(\"Failed to read the mesh. The file format may not be supported.\") else: print(\"Successfully read the mesh.\") # 计算法线 mesh.compute_vertex_normals() # 设置网格的颜色为红色 mesh.paint_uniform_color([1, 0, 0]) # 设置为红色 # 创建一个可视化窗口 vis = o3d.visualization.Visualizer() vis.create_window() # 添加网格到可视化窗口 vis.add_geometry(mesh) # 更新几何体和渲染器 vis.update_geometry(mesh) vis.poll_events() vis.update_renderer() # 渲染 vis.run() vis.destroy_window()   \nimport open3d as o3d import numpy as np # 定义文件路径 filename = \"doll.stl\" # 读取三角网格 mesh = o3d.io.read_triangle_mesh(filename) if mesh.is_empty(): print(\"Failed to read the mesh. The file format may not be supported.\") else: print(\"Successfully read the mesh.\") # 计算法线 mesh.compute_vertex_normals() # 设置材质 mat_box = o3d.visualization.rendering.MaterialRecord() mat_box.shader = 'defaultLitSSR' mat_box.base_color = [0.467, 0.467, 0.467, 0.2] # 设置透明度为0.2 mat_box.base_roughness = 0.0 mat_box.base_reflectance = 0.0 mat_box.base_clearcoat = 1.0 mat_box.thickness = 1.0 mat_box.transmission = 1.0 mat_box.absorption_distance = 10 mat_box.absorption_color = [0.5, 0.5, 0.5] # 使用draw函数渲染 o3d.visualization.draw( [{'name': 'box', 'geometry': mesh, 'material': mat_box}], show_skybox=False, width=800, height=600, bg_color=[0.5, 0.5, 0.5, 0.8] # 设置背景颜色为灰色 )   \n4.4 从mesh上提取点云 import open3d as o3d import numpy as np # 定义文件路径 filename = \"doll.stl\" # 读取三角网格 mesh = o3d.io.read_triangle_mesh(filename) if mesh.is_empty(): print(\"Failed to read the mesh. The file format may not be supported.\") else: print(\"Successfully read the mesh.\") # 计算法线 mesh.compute_vertex_normals() # 从mesh提取点云 point_cloud = mesh.sample_points_uniformly(number_of_points=10000) # 设置材质 mat_box = o3d.visualization.rendering.MaterialRecord() mat_box.shader = 'defaultLitSSR' mat_box.base_color = [0.467, 0.467, 0.467, 0.2] # 设置透明度为0.2 mat_box.base_roughness = 0.0 mat_box.base_reflectance = 0.0 mat_box.base_clearcoat = 1.0 mat_box.thickness = 1.0 mat_box.transmission = 1.0 mat_box.absorption_distance = 10 mat_box.absorption_color = [0.5, 0.5, 0.5] # 使用draw函数渲染 o3d.visualization.draw( [{'name': 'box', 'geometry': mesh, 'material': mat_box}, {'name': 'point_cloud', 'geometry': point_cloud}], show_skybox=False, width=800, height=600, bg_color=[0.5, 0.5, 0.5, 0.8] # 设置背景颜色为灰色 )   \n5. KD-Tree 5.1 KD-树 说明与算法原理 5.1.1 KD-树的简介 KD-树（K-Dimension Tree）是一种用于多维空间数据的搜索数据结构，其构建和搜索过程类似于二叉搜索树，但适用于高维场景。通过交替使用各维特征进行划分，KD-树能在 (O(\\log N)) 的时间复杂度内实现最近邻搜索。此外，它还支持动态插入新节点，通过一种类似替罪羊树的方法保持一定的结构平衡，确保插入效率。 另外, 可以直接看wiki的说明: https://en.wikipedia.org/wiki/K-d_tree\n5.1.2 KD-树的构建 KD-树的构建过程如下：\n 选择分割维度：从根节点开始，依次选择各维度进行分割。通常选择数据点在该维度上的中位数作为分割点。 递归构建子树：将数据点分为两部分，左子树包含小于等于分割点的数据点，右子树包含大于分割点的数据点。递归地对每个子树进行上述操作，直到所有数据点都被处理完。  5.1.3 KD-树的搜索 KD-树的搜索过程如下：\n 递归搜索：从根节点开始，根据查询点在当前分割维度上的值，递归地搜索左子树或右子树。 回溯检查：在回溯过程中，检查当前节点是否比已找到的最近邻更接近查询点。如果是，则更新最近邻。 检查其他子树：如果查询点与当前分割平面的距离小于已找到的最近邻距离，则需要检查另一个子树。  5.1.4 KD-树的插入 KD-树的插入过程如下：\n 找到插入位置：从根节点开始，递归地找到适合插入新节点的位置。 插入新节点：在找到的插入位置插入新节点，并根据需要调整树的结构以保持平衡。  5.1.5 KD-树的应用 KD-树广泛应用于以下场景：\n 最近邻搜索：在点云处理、图像检索等领域，KD-树可以高效地找到距离查询点最近的点。 范围查询：在地理信息系统中，KD-树可以用于查找指定范围内的所有点。 聚类分析：在机器学习中，KD-树可以用于加速 K-means 聚类算法。  5.1.6 KD-树的C++实现 以下是一个简单的 KD-树的 C++ 实现示例：\n#include #include #include  struct Point { std::vectordouble coords; Point(std::initializer_listdouble init) : coords(init) {} }; struct KDNode { Point point; KDNode* left; KDNode* right; KDNode(Point p) : point(p), left(nullptr), right(nullptr) {} }; class KDTree { public: KDTree(const std::vectorPoint\u0026 points) { root = build(points, 0); } KDNode* build(const std::vectorPoint\u0026 points, int depth) { if (points.empty()) return nullptr; int k = points[0].coords.size(); int axis = depth % k; std::vectorPoint sorted_points = points; std::sort(sorted_points.begin(), sorted_points.end(), [axis](const Point\u0026 a, const Point\u0026 b) { return a.coords[axis]  b.coords[axis]; }); int median = sorted_points.size() / 2; KDNode* node = new KDNode(sorted_points[median]); std::vectorPoint left_points(sorted_points.begin(), sorted_points.begin() + median); std::vectorPoint right_points(sorted_points.begin() + median + 1, sorted_points.end()); node-left = build(left_points, depth + 1); node-right = build(right_points, depth + 1); return node; } void nearestNeighborSearch(const Point\u0026 query, Point\u0026 best, double\u0026 best_dist, KDNode* node, int depth) { if (!node) return; int k = query.coords.size(); int axis = depth % k; double dist = distance(query, node-point); if (dist  best_dist) { best_dist = dist; best = node-point; } double diff = query.coords[axis] - node-point.coords[axis]; KDNode* near = diff  0 ? node-left : node-right; KDNode* far = diff  0 ? node-right : node-left; nearestNeighborSearch(query, best, best_dist, near, depth + 1); if (std::abs(diff)  best_dist) { nearestNeighborSearch(query, best, best_dist, far, depth + 1); } } Point nearestNeighbor(const Point\u0026 query) { Point best = root-point; double best_dist = distance(query, best); nearestNeighborSearch(query, best, best_dist, root, 0); return best; } private: KDNode* root; double distance(const Point\u0026 a, const Point\u0026 b) { double dist = 0; for (size_t i = 0; i  a.coords.size(); ++i) { dist += (a.coords[i] - b.coords[i]) * (a.coords[i] - b.coords[i]); } return dist; } }; int main() { std::vectorPoint points = {{2.0, 3.0}, {5.0, 4.0}, {9.0, 6.0}, {4.0, 7.0}, {8.0, 1.0}, {7.0, 2.0}}; KDTree tree(points); Point query = {9.0, 2.0}; Point nearest = tree.nearestNeighbor(query); std::cout  \"最近邻点: (\"  nearest.coords[0]  \", \"  nearest.coords[1]  \")\\n\"; return 0; } KD-树是一种高效的多维空间数据搜索结构，适用于最近邻搜索、范围查询和聚类分析等场景。通过交替使用各维特征进行划分，KD-树能在 (O(\\log N)) 的时间复杂度内实现高效搜索。\n5.2 KDTreeFlann接口 Open3D 提供了 KDTreeFlann 类，用于高效的空间查询。主要的接口包括：\n  search_knn_vector_3d：最近邻搜索\n[k, idx, dist] = kdtree.search_knn_vector_3d(query_point, k)  query_point：查询点 k：返回最近邻的数量 返回值：k 为找到的邻居数量，idx 为邻居的索引，dist 为邻居的距离    search_radius_vector_3d：半径搜索\n[k, idx, dist] = kdtree.search_radius_vector_3d(query_point, radius)  query_point：查询点 radius：搜索半径 返回值：k 为找到的邻居数量，idx 为邻居的索引，dist 为邻居的距离    search_hybrid_vector_3d：固定距离搜索\n[k, idx, dist] = kdtree.search_hybrid_vector_3d(query_point, radius, max_nn)  query_point：查询点 radius：搜索半径 max_nn：返回的最大邻居数量 返回值：k 为找到的邻居数量，idx 为邻居的索引，dist 为邻居的距离    5.3 Open3D 中 k-d 树的接口案例 以下是使用 Open3D 构建和查询 k-d 树的示例代码：\nimport open3d as o3d import numpy as np # 创建一个随机点云 pcd = o3d.geometry.PointCloud() pcd.points = o3d.utility.Vector3dVector(np.random.rand(5000, 3)) # 为点云设置颜色 colors = np.random.rand(5000, 3) # 随机颜色 pcd.colors = o3d.utility.Vector3dVector(colors) # 构建k-d tree kdtree = o3d.geometry.KDTreeFlann(pcd) # 查询k-d tree中的最近邻 query_point = np.random.rand(3) [k, idx, dist] = kdtree.search_knn_vector_3d(query_point, 10) print(\"查询点:\", query_point) print(\"k-d tree最近邻索引:\", idx) print(\"k-d tree最近邻距离:\", dist) # 提取最近邻点 nearest_points = np.asarray(pcd.points)[idx, :] # 创建查询点和最近邻点的点云 query_pcd = o3d.geometry.PointCloud() query_pcd.points = o3d.utility.Vector3dVector([query_point]) query_pcd.paint_uniform_color([1, 0, 0]) # 将查询点设置为红色 nearest_pcd = o3d.geometry.PointCloud() nearest_pcd.points = o3d.utility.Vector3dVector(nearest_points) nearest_pcd.paint_uniform_color([0, 1, 0]) # 将最近邻点设置为绿色 # 可视化点云、查询点和最近邻点 vis = o3d.visualization.Visualizer() vis.create_window() vis.add_geometry(pcd) vis.add_geometry(query_pcd) vis.add_geometry(nearest_pcd) # 调整点云大小 opt = vis.get_render_option() opt.point_size = 2.0 # 设置原始点云大小 opt.background_color = np.asarray([0.8, 0.8, 0.8]) # 设置背景颜色 # 放大最近邻点的大小 for i in range(len(nearest_pcd.points)): sphere = o3d.geometry.TriangleMesh.create_sphere(radius=0.02) sphere.translate(nearest_pcd.points[i]) sphere.paint_uniform_color([0, 1, 0]) vis.add_geometry(sphere) # 更新可视化 vis.poll_events() vis.update_renderer() vis.run() vis.destroy_window()   \n 创建点云：生成一个包含 1000 个随机点的点云。 构建 k-d 树：使用 o3d.geometry.KDTreeFlann 构建 k-d 树。 查询最近邻：使用 search_knn_vector_3d 方法查询给定点的 5 个最近邻。 提取最近邻点：从点云中提取最近邻点。 设置颜色：将原始点云设置为灰色，查询点设置为红色，最近邻点设置为绿色。 可视化：将点云、查询点和最近邻点一起可视化。  6. Octree 八叉树 Octree 八叉树是一种用于描述三维空间的树状数据结构。它的基本思想是递归地将三维空间划分成更小的体积单元，每个节点表示一个正方体的体积元素，每个节点有八个子节点，将八个子节点所表示的体积元素加在一起就等于父节点的体积。 另外, 可以直接看wiki的说明: https://en.wikipedia.org/wiki/Octree \n6.1 基本原理 6.1.1 构建八叉树  根节点：八叉树的根节点表示整个三维空间或一个较大的正方体。 划分空间：将空间划分为八个相等的子空间，每个子空间对应一个子节点。 递归划分：对于每个子节点，如果其包含的元素数量超过预设阈值，则继续递归地将该子节点对应的空间再划分为八个更小的子空间，直到每个子节点包含的元素数量小于或等于阈值，或者达到设定的最大深度。  6.1.2 节点结构 每个八叉树节点包含以下信息：\n 边界（Boundary）：定义了节点所代表的空间区域。 子节点（Children）：指向八个子节点的指针。 元素（Elements）：节点所包含的元素列表，通常是点、物体或其他空间实体。  6.1.3 空间划分 在三维空间中，每个节点代表一个正方体，可以通过中心点和边长来定义。将正方体沿三个坐标轴（x、y、z）各切一刀，就可以得到八个子正方体。\n6.2 应用 6.2.1 空间划分 八叉树常用于三维空间的分层表示和管理，例如在计算机图形学中用于加速光线追踪和碰撞检测。通过将复杂的三维场景划分成更小的区域，可以大大减少需要处理的元素数量，从而提高计算效率。\n6.2.2 最近邻搜索 在三维空间中查找某个点的最近邻居时，可以利用八叉树快速缩小搜索范围。通过递归地检查包含目标点的节点及其相邻节点，可以高效地找到最近邻居。\n6.2.3 碰撞检测 在物理引擎中，八叉树被广泛用于碰撞检测。通过将物体划分到不同的节点中，可以快速确定哪些物体可能发生碰撞，从而减少不必要的碰撞检测计算。\n6.2.4 空间索引 八叉树也可以用于空间数据库中的空间索引，支持快速的空间查询操作，如范围查询和K近邻查询。\n6.3 实现细节 6.3.1 插入元素 将一个元素插入八叉树时，首先找到包含该元素的节点，然后递归地检查该节点是否需要进一步划分，直到找到最适合的叶子节点，将元素插入其中。\n6.3.2 查找元素 查找元素时，从根节点开始，根据元素的位置递归地进入对应的子节点，直到找到包含该元素的节点。\n6.3.3 删除元素 删除元素时，首先找到包含该元素的节点，然后从节点的元素列表中删除该元素。如果删除后节点的元素数量小于阈值，则可以考虑合并该节点的子节点以减少树的深度。\n6.4 优缺点 6.4.1 优点  高效的空间划分：八叉树可以高效地划分三维空间，适用于处理大规模三维数据。 快速查询：支持快速的空间查询操作，如最近邻搜索和碰撞检测。 灵活性：可以自适应地划分空间，根据需要调整树的深度和节点容量。  6.4.2 缺点  内存消耗：在处理大规模数据时，八叉树的节点数量可能非常庞大，导致较高的内存消耗。 复杂性：实现和维护八叉树的数据结构相对复杂，特别是在处理动态数据时。  八叉树是一种强大的数据结构，广泛应用于三维空间的划分和管理。通过递归地将三维空间划分为更小的体积单元，八叉树可以高效地支持各种空间查询操作，如最近邻搜索和碰撞检测。然而，在实际应用中，需要权衡其内存消耗和实现复杂性，以确保其高效性和实用性。\n6.4 Open3D Octree Octree 类是 Open3D 中用于三维空间分割的主要类。它提供了构建、插入、查询等功能。\n6.4.1 构建 Octree 要构建一个 Octree，可以使用 Octree 类并指定最大深度：\nimport open3d as o3d # 创建一个 Octree，指定最大深度 max_depth = 4 octree = o3d.geometry.Octree(max_depth) 6.4.2 从点云构建 Octree 可以从一个点云构建 Octree：\n# 创建一个随机点云 pcd = o3d.geometry.PointCloud() pcd.points = o3d.utility.Vector3dVector(np.random.rand(5000, 3)) # 从点云构建 Octree octree.convert_from_point_cloud(pcd, size_expand=0.01) 6.4.3 插入点 可以向 Octree 中插入单个点：\npoint = [0.5, 0.5, 0.5] octree.insert_point(point) 6.4.4 查询点 可以查询一个点是否在 Octree 中，并获取其所在的叶节点信息：\nquery_point = [0.5, 0.5, 0.5] success, node_info = octree.locate_leaf_node(query_point) print(\"查询成功:\", success) print(\"节点信息:\", node_info) 6.4.5 可视化 Octree 可以使用 Open3D 的可视化工具来显示 Octree：\no3d.visualization.draw_geometries([octree]) 6.4.6 完整示例代码 以下是一个完整的示例代码，展示了如何构建、插入、查询和可视化 Octree：\nimport open3d as o3d import numpy as np # 创建一个随机点云 pcd = o3d.geometry.PointCloud() pcd.points = o3d.utility.Vector3dVector(np.random.rand(5000, 3)) # 构建 Octree max_depth = 4 octree = o3d.geometry.Octree(max_depth) octree.convert_from_point_cloud(pcd, size_expand=0.01) # 插入多个点 points = np.random.rand(100, 3) # 生成 100 个随机点 def leaf_node_init(): return o3d.geometry.OctreeColorLeafNode() def leaf_node_update(node): pass def internal_node_init(): return o3d.geometry.OctreeInternalNode() def internal_node_update(node): pass for point in points: octree.insert_point(point, leaf_node_init, leaf_node_update, internal_node_init, internal_node_update) # 查询 Octree 中的点 query_point = np.array([0.5, 0.5, 0.5]) success, node_info = octree.locate_leaf_node(query_point) print(\"查询点:\", query_point) print(\"查询成功:\", success) print(\"节点信息:\", node_info) # 可视化 Octree 节点 def create_pointcloud_from_octree(octree): points = [] colors = [] def traverse(node, node_info): if isinstance(node, o3d.geometry.OctreeColorLeafNode): origin = node_info.origin size = node_info.size depth = node_info.depth # 根据深度设置颜色 if depth == 0: color = [1, 0, 0] # 红色 elif depth == 1: color = [0, 1, 0] # 绿色 elif depth == 2: color = [0, 0, 1] # 蓝色 elif depth == 3: color = [1, 1, 0] # 黄色 else: color = [0, 1, 1] # 青色 points.append(origin + size / 2) colors.append(color) return False octree.traverse(traverse) pointcloud = o3d.geometry.PointCloud() pointcloud.points = o3d.utility.Vector3dVector(np.array(points)) pointcloud.colors = o3d.utility.Vector3dVector(np.array(colors)) return pointcloud octree_pointcloud = create_pointcloud_from_octree(octree) # 创建 Octree 的线框表示 def create_lineset_from_octree(octree): lines = [] colors = [] points = [] def traverse(node, node_info): if isinstance(node, o3d.geometry.OctreeColorLeafNode) or isinstance(node, o3d.geometry.OctreeInternalNode): origin = node_info.origin size = node_info.size # 添加立方体的 12 条边 cube_lines = [ [0, 1], [1, 3], [3, 2], [2, 0], # 底面 [4, 5], [5, 7], [7, 6], [6, 4], # 顶面 [0, 4], [1, 5], [2, 6], [3, 7] # 侧面 ] cube_points = [ origin, origin + [size, 0, 0], origin + [0, size, 0], origin + [size, size, 0], origin + [0, 0, size], origin + [size, 0, size], origin + [0, size, size], origin + [size, size, size] ] base_index = len(points) points.extend(cube_points) lines.extend([[base_index + start, base_index + end] for start, end in cube_lines]) colors.extend([[0, 0, 0] for _ in range(len(cube_lines))]) # 黑色 return False octree.traverse(traverse) lineset = o3d.geometry.LineSet() lineset.points = o3d.utility.Vector3dVector(np.array(points)) lineset.lines = o3d.utility.Vector2iVector(np.array(lines)) lineset.colors = o3d.utility.Vector3dVector(np.array(colors)) return lineset octree_lineset = create_lineset_from_octree(octree) # 创建找到的立方体 if success: origin = node_info.origin size = node_info.size cube = o3d.geometry.TriangleMesh.create_box(width=size, height=size, depth=size) cube.translate(origin) cube.paint_uniform_color([1, 0, 0]) # 红色 # 使用默认的绘制函数来显示点云和 Octree geometries = [octree_pointcloud, octree_lineset] if success: geometries.append(cube) o3d.visualization.draw_geometries(geometries)    这段代码展示了如何使用 Open3D 库创建一个 Octree，插入点，查询节点，并可视化 Octree 结构及其节点。\n  创建随机点云：\npcd = o3d.geometry.PointCloud() pcd.points = o3d.utility.Vector3dVector(np.random.rand(5000, 3))   构建 Octree：\noctree = o3d.geometry.Octree(max_depth=4) octree.convert_from_point_cloud(pcd, size_expand=0.01)   插入多个点：\npoints = np.random.rand(100, 3) for point in points: octree.insert_point(point, leaf_node_init, leaf_node_update, internal_node_init, internal_node_update)   查询 Octree 中的点：\nquery_point = np.array([0.5, 0.5, 0.5]) success, node_info = octree.locate_leaf_node(query_point)   可视化 Octree 和查询结果：\noctree_pointcloud = create_pointcloud_from_octree(octree) octree_lineset = create_lineset_from_octree(octree) if success: cube = o3d.geometry.TriangleMesh.create_box(width=node_info.size, height=node_info.size, depth=node_info.size) cube.translate(node_info.origin) cube.paint_uniform_color([1, 0, 0]) geometries = [octree_pointcloud, octree_lineset, cube] if success else [octree_pointcloud, octree_lineset] o3d.visualization.draw_geometries(geometries)   6.4.7 点云分割 在 Open3D 中使用 Octree 进行点云分割可以通过以下步骤实现：\n  创建点云并构建 Octree：\n 创建一个点云对象并填充点数据。 使用点云数据构建 Octree。    遍历 Octree 并分割点云：\n 遍历 Octree 的叶节点。 根据叶节点的信息将点云分割成不同的部分。    import open3d as o3d import numpy as np # 创建多个点云簇 def create_clustered_point_cloud(num_clusters=5, points_per_cluster=2000, cluster_radius=0.05): points = [] for i in range(num_clusters): cluster_center = np.random.rand(3) cluster_points = cluster_center + cluster_radius * np.random.randn(points_per_cluster, 3) points.append(cluster_points) return np.vstack(points) # 生成点云 pcd = o3d.geometry.PointCloud() pcd.points = o3d.utility.Vector3dVector(create_clustered_point_cloud()) # 构建 Octree max_depth = 4 # 调整 Octree 的深度 octree = o3d.geometry.Octree(max_depth) octree.convert_from_point_cloud(pcd, size_expand=0.01) # 分割点云并为每个部分赋予不同的颜色 def segment_point_cloud(octree): segments = [] colors = np.random.rand(100, 3) # 生成随机颜色 color_index = 0 def traverse(node, node_info): nonlocal color_index if isinstance(node, o3d.geometry.OctreeLeafNode): # 获取叶节点中的点 segment = pcd.select_by_index(node.indices) segment.paint_uniform_color(colors[color_index % len(colors)]) segments.append(segment) color_index += 1 return False octree.traverse(traverse) return segments # 获取分割后的点云部分 segments = segment_point_cloud(octree) # 检查是否有分割后的点云部分 if len(segments) == 0: print(\"没有分割后的点云部分，请检查 Octree 构建和遍历逻辑。\") else: # 可视化分割后的点云 o3d.visualization.draw_geometries(segments)   \n6.4.8 点云过滤 在 Open3D 中使用 Octree 进行点云滤波可以通过以下步骤实现：\n 创建点云并构建 Octree。 定义滤波条件。 遍历 Octree 并应用滤波条件。 生成滤波后的点云。  import open3d as o3d import numpy as np # 创建一个随机点云 pcd = o3d.geometry.PointCloud() pcd.points = o3d.utility.Vector3dVector(np.random.rand(10000, 3)) # 构建 Octree max_depth = 4 # 调整 Octree 的深度 octree = o3d.geometry.Octree(max_depth) octree.convert_from_point_cloud(pcd, size_expand=0.01) # 定义体素滤波函数 def voxel_filter(octree, voxel_size): filtered_points = [] def traverse(node, node_info): if isinstance(node, o3d.geometry.OctreeLeafNode): # 计算叶节点的中心点 voxel_center = node_info.origin + node_info.size / 2 filtered_points.append(voxel_center) return False octree.traverse(traverse) return filtered_points # 设置体素大小 voxel_size = 0.05 # 获取滤波后的点云 filtered_points = voxel_filter(octree, voxel_size) filtered_pcd = o3d.geometry.PointCloud() filtered_pcd.points = o3d.utility.Vector3dVector(filtered_points) # 可视化原始点云和滤波后的点云 print(\"原始点云点数:\", len(pcd.points)) print(\"滤波后点云点数:\", len(filtered_pcd.points)) o3d.visualization.draw_geometries([pcd], window_name=\"原始点云\") o3d.visualization.draw_geometries([filtered_pcd], window_name=\"滤波后点云\")    过滤前 过滤后              7. 点云过滤 Open3D 提供了以下几种常用的点云滤波方法：\n  统计滤波 (Statistical Outlier Removal)：\n 方法：remove_statistical_outlier 参数：  nb_neighbors：用于计算平均距离的邻居点数。 std_ratio：距离的标准差乘数。      半径滤波 (Radius Outlier Removal)：\n 方法：remove_radius_outlier 参数：  nb_points：在指定半径内的最小点数。 radius：搜索半径。      体素下采样 (Voxel Downsampling)：\n 方法：voxel_down_sample 参数：  voxel_size：体素的大小。      Uniform Downsampling：\n 方法：uniform_down_sample 参数：  every_k_points：每隔多少个点采样一个点。      以下是这些方法的示例代码：\nimport open3d as o3d import numpy as np # 创建一个随机点云 pcd = o3d.geometry.PointCloud() pcd.points = o3d.utility.Vector3dVector(np.random.rand(10000, 3)) # 统计滤波 pcd_statistical, ind_statistical = pcd.remove_statistical_outlier(nb_neighbors=20, std_ratio=1.0) filtered_pcd_statistical = pcd.select_by_index(ind_statistical) # 半径滤波 pcd_radius, ind_radius = pcd.remove_radius_outlier(nb_points=10, radius=0.1) filtered_pcd_radius = pcd.select_by_index(ind_radius) # 体素下采样 voxel_size = 0.05 downsampled_pcd_voxel = pcd.voxel_down_sample(voxel_size) # Uniform 下采样 every_k_points = 10 downsampled_pcd_uniform = pcd.uniform_down_sample(every_k_points) # 可视化原始点云和过滤后的点云 print(\"原始点云点数:\", len(pcd.points)) print(\"统计滤波后的点云点数:\", len(filtered_pcd_statistical.points)) print(\"半径滤波后的点云点数:\", len(filtered_pcd_radius.points)) print(\"体素下采样后的点云点数:\", len(downsampled_pcd_voxel.points)) print(\"Uniform下采样后的点云点数:\", len(downsampled_pcd_uniform.points)) o3d.visualization.draw_geometries([pcd], window_name=\"原始点云\") o3d.visualization.draw_geometries([filtered_pcd_statistical], window_name=\"统计滤波后的点云\") o3d.visualization.draw_geometries([filtered_pcd_radius], window_name=\"半径滤波后的点云\") o3d.visualization.draw_geometries([downsampled_pcd_voxel], window_name=\"体素下采样后的点云\") o3d.visualization.draw_geometries([downsampled_pcd_uniform], window_name=\"Uniform下采样后的点云\")           \n 代码说明：   统计滤波：使用 remove_statistical_outlier 方法去除离群点。该方法通过计算每个点的邻居点的平均距离，并将距离超过标准差乘数的点视为离群点。参数 nb_neighbors 指定用于计算平均距离的邻居点数，std_ratio 指定距离的标准差乘数。 半径滤波：使用 remove_radius_outlier 方法去除孤立点。该方法通过检查每个点在指定半径内的邻居点数，并将邻居点数少于指定值的点视为孤立点。参数 nb_points 指定在指定半径内的最小点数，radius 指定搜索半径。 体素下采样：使用 voxel_down_sample 方法通过体素网格下采样点云。该方法将点云划分为体素网格，并用每个体素内的点的重心来代表该体素。参数 voxel_size 指定体素的大小。 Uniform 下采样：使用 uniform_down_sample 方法均匀下采样点云。该方法通过按固定间隔选择点来下采样点云。参数 every_k_points 指定每隔多少个点采样一个点。  这些方法可以帮助你在不同的场景下对点云进行预处理和优化，以提高点云处理的效率和效果。\n8. 点云转换 8.1 transform：应用变换矩阵到点云 transform 方法用于将一个 4x4 的变换矩阵应用到点云上。该矩阵可以包含平移、旋转和缩放。\nimport open3d as o3d import numpy as np # 创建一个随机点云 pcd = o3d.geometry.PointCloud() pcd.points = o3d.utility.Vector3dVector(np.random.rand(1000, 3)) # 定义一个变换矩阵 transformation_matrix = np.array([[1, 0, 0, 1], [0, 1, 0, 2], [0, 0, 1, 3], [0, 0, 0, 1]]) # 应用变换矩阵到点云 pcd.transform(transformation_matrix) # 可视化变换后的点云 o3d.visualization.draw_geometries([pcd], window_name=\"Transformed Point Cloud\") 8.2 translate：平移点云 translate 方法用于将点云沿指定的方向平移。\n# 平移向量 translation_vector = np.array([1, 2, 3]) # 平移点云 pcd.translate(translation_vector) # 可视化平移后的点云 o3d.visualization.draw_geometries([pcd], window_name=\"Translated Point Cloud\") 8.3 rotate：旋转点云 rotate 方法用于将点云绕指定的轴旋转。旋转矩阵可以通过欧拉角或四元数生成。\n# 定义一个旋转矩阵（绕 Z 轴旋转 45 度） rotation_matrix = pcd.get_rotation_matrix_from_xyz((0, 0, np.pi / 4)) # 旋转点云 pcd.rotate(rotation_matrix, center=(0, 0, 0)) # 可视化旋转后的点云 o3d.visualization.draw_geometries([pcd], window_name=\"Rotated Point Cloud\") 8.4 scale：缩放点云 scale 方法用于将点云按指定的比例缩放。\n# 缩放比例 scale_factor = 2.0 # 缩放点云 pcd.scale(scale_factor, center=pcd.get_center()) # 可视化缩放后的点云 o3d.visualization.draw_geometries([pcd], window_name=\"Scaled Point Cloud\") 9. 点云法线估计 9.1 estimate_normals：估计点云法线 estimate_normals 方法用于估计点云的法线。该方法通过计算每个点的邻域点的协方差矩阵，并求解其特征向量来确定法线方向。\n 参数说明： search_param：搜索参数，定义了用于法线估计的邻域搜索方法和半径。  search_param=o3d.geometry.KDTreeSearchParamKNN(knn)：使用 K 近邻搜索，knn 为邻居点的数量。 search_param=o3d.geometry.KDTreeSearchParamRadius(radius)：使用半径搜索，radius 为搜索半径。    9.2 orient_normals_consistent_tangent_plane：使法线方向一致 orient_normals_consistent_tangent_plane 方法用于使点云的法线方向一致。该方法通过构建一致的切平面来调整法线方向。\n 参数说明： k：用于一致性调整的邻居点数量。  9.3 详细案例 以下是一个完整的案例，展示了如何读取点云、估计法线并使法线方向一致：\nimport open3d as o3d import numpy as np # 生成点云数据 def generate_point_cloud(): # 生成一个简单的平面点云 mesh = o3d.geometry.TriangleMesh.create_sphere(radius=1.0) pcd = mesh.sample_points_poisson_disk(number_of_points=500) return pcd # 生成点云 pcd = generate_point_cloud() # 打印点云信息 print(\"Point cloud before normal estimation:\") print(pcd) # 估计法线 print(\"Estimating normals...\") pcd.estimate_normals(search_param=o3d.geometry.KDTreeSearchParamKNN(knn=30)) # 打印估计法线后的点云信息 print(\"Point cloud after normal estimation:\") print(pcd) # 可视化带法线的点云 o3d.visualization.draw_geometries([pcd], point_show_normal=True, window_name=\"Point Cloud with Normals\") # 使法线方向一致 print(\"Orienting normals consistently...\") pcd.orient_normals_consistent_tangent_plane(k=30) # 打印调整法线方向后的点云信息 print(\"Point cloud after orienting normals:\") print(pcd) # 可视化带一致法线的点云 o3d.visualization.draw_geometries([pcd], point_show_normal=True, window_name=\"Point Cloud with Oriented Normals\")    法向生成 法向统一              通过 estimate_normals 和 orient_normals_consistent_tangent_plane 方法，你可以估计点云的法线并使其方向一致。这对于后续的点云处理和分析（如表面重建、配准等）非常重要。\n10. 点云配准 Open3D 提供了多种点云配准方法，主要包括以下几种：\n  ICP (Iterative Closest Point) 配准：这是最常用的点云配准方法之一，通过迭代地最小化两组点云之间的距离来实现配准。\n  Colored ICP 配准：这是对传统 ICP 的改进，除了几何距离外，还考虑了颜色信息来进行配准。\n  Global Registration (全局配准)：用于初始配准，通常在没有初始对齐的情况下使用。包括 RANSAC-based 和 Fast Global Registration (FGR) 方法。\n  Multiway Registration (多路配准)：用于将多个点云配准到一个共同的参考框架中。\n  下面是每种方法的说明和案例：\n10.1 ICP 配准 说明：通过迭代地最小化两组点云之间的距离来实现配准。\n案例：\nimport open3d as o3d import numpy as np def create_colored_point_cloud(color): \"\"\"创建并上色的球体点云\"\"\" pcd = o3d.geometry.TriangleMesh.create_sphere(radius=1.0).sample_points_uniformly(number_of_points=1000) pcd.paint_uniform_color(color) return pcd def visualize_point_clouds(pcd1, pcd2, window_name): \"\"\"可视化点云\"\"\" o3d.visualization.draw_geometries([pcd1, pcd2], window_name=window_name) # 生成并上色两个相似的点云 pcd1 = create_colored_point_cloud([1, 0, 0]) # 红色 pcd2 = create_colored_point_cloud([0, 1, 0]) # 绿色 # 对第二个点云进行初始变换 initial_transformation = np.array([[0.862, 0.011, -0.507, 0.5], [-0.139, 0.967, -0.215, 0.7], [0.487, 0.255, 0.835, -1.4], [0.0, 0.0, 0.0, 1.0]]) pcd2.transform(initial_transformation) # 可视化初始点云 visualize_point_clouds(pcd1, pcd2, \"Initial Point Clouds\") # 使用 ICP 进行配准 threshold = 0.7 # 增加阈值 trans_init = np.eye(4) reg_p2p = o3d.pipelines.registration.registration_icp( pcd1, pcd2, threshold, trans_init, o3d.pipelines.registration.TransformationEstimationPointToPoint() ) # 打印配准信息 print(\"ICP converged:\", reg_p2p.inlier_rmse  threshold) print(\"Fitness:\", reg_p2p.fitness) print(\"Inlier RMSE:\", reg_p2p.inlier_rmse) print(\"Transformation matrix:\") print(reg_p2p.transformation) # 计算逆矩阵 inverse_transformation = np.linalg.inv(reg_p2p.transformation) # 应用逆矩阵到第二个点云 pcd2.transform(inverse_transformation) # 可视化配准后的点云 visualize_point_clouds(pcd1, pcd2, \"Aligned Point Clouds\")    原始点云 配准点云              10.2 Colored ICP 配准 说明：在传统 ICP 的基础上，考虑了颜色信息来进行配准。\nimport open3d as o3d import numpy as np def create_colored_sphere(radius, color, density=1000): mesh = o3d.geometry.TriangleMesh.create_sphere(radius=radius) pcd = mesh.sample_points_poisson_disk(number_of_points=density) pcd.paint_uniform_color(color) return pcd def estimate_normals(pcd, radius=0.1, max_nn=30): pcd.estimate_normals(search_param=o3d.geometry.KDTreeSearchParamHybrid(radius=radius, max_nn=max_nn)) def execute_colored_icp(source, target, max_correspondence_distance, initial_transformation): criteria = o3d.pipelines.registration.ICPConvergenceCriteria( relative_fitness=1e-3, relative_rmse=1e-3, max_iteration=500) result = o3d.pipelines.registration.registration_colored_icp( source, target, max_correspondence_distance, initial_transformation, o3d.pipelines.registration.TransformationEstimationForColoredICP(), criteria) return result # 创建两个绿色的球体 sphere1 = create_colored_sphere(1.0, [0, 1, 0], density=1000) sphere2 = create_colored_sphere(1.0, [0, 1, 0], density=1000) # 对第二个球体进行变换 transformation = np.array([[0.862, 0.011, -0.507, 0.5], [-0.139, 0.967, -0.215, 0.7], [0.487, 0.255, 0.835, -1.4], [0.0, 0.0, 0.0, 1.0]]) sphere2.transform(transformation) # 估算法线 estimate_normals(sphere1) estimate_normals(sphere2) # 可视化配准前的点云 print(\"配准前的点云：\") o3d.visualization.draw_geometries([sphere1, sphere2], window_name=\"Before Registration\") # 使用彩色ICP进行配准 max_correspondence_distance = 5.0 # 增大最大对应点距离 initial_transformation = np.identity(4) result_colored_icp = execute_colored_icp(sphere1, sphere2, max_correspondence_distance, initial_transformation) # 应用变换到第一个球体点云 sphere1.transform(result_colored_icp.transformation) # 可视化配准后的点云 print(\"配准后的点云：\") o3d.visualization.draw_geometries([sphere1, sphere2], window_name=\"After Registration\")  代码说明：   创建彩色球体：使用 create_colored_sphere 函数创建两个绿色的球体。 对第二个球体进行变换：对第二个球体进行随机变换。 估算法线：计算球体点云的法线。 可视化配准前的点云：在配准前显示两个球体点云。 使用彩色ICP进行配准：使用彩色ICP算法进行配准。 应用变换到第一个球体点云：将配准结果应用到第一个球体点云。 可视化配准后的点云：在配准后显示两个球体点云。     原始点云 配准点云              10.3 全局配准 说明：用于初始配准，通常在没有初始对齐的情况下使用。\n好的，以下是包含配准前后可视化的完整代码：\nimport open3d as o3d import numpy as np # 生成点云数据 def generate_point_cloud(): # 创建一个球体点云 mesh = o3d.geometry.TriangleMesh.create_sphere(radius=1.0) pcd = mesh.sample_points_poisson_disk(number_of_points=500) return pcd # 生成源点云和目标点云 source = generate_point_cloud() target = generate_point_cloud() # 对目标点云进行随机变换 transformation = np.array([[0.862, 0.011, -0.507, 0.5], [-0.139, 0.967, -0.215, 0.7], [0.487, 0.255, 0.835, -1.4], [0.0, 0.0, 0.0, 1.0]]) target.transform(transformation) # 下采样点云 voxel_size = 0.05 source_down = source.voxel_down_sample(voxel_size) target_down = target.voxel_down_sample(voxel_size) # 估计法线 source_down.estimate_normals(search_param=o3d.geometry.KDTreeSearchParamHybrid(radius=0.1, max_nn=30)) target_down.estimate_normals(search_param=o3d.geometry.KDTreeSearchParamHybrid(radius=0.1, max_nn=30)) # 计算FPFH特征 source_fpfh = o3d.pipelines.registration.compute_fpfh_feature( source_down, o3d.geometry.KDTreeSearchParamHybrid(radius=0.25, max_nn=100)) target_fpfh = o3d.pipelines.registration.compute_fpfh_feature( target_down, o3d.geometry.KDTreeSearchParamHybrid(radius=0.25, max_nn=100)) # 使用RANSAC进行全局配准 result_ransac = o3d.pipelines.registration.registration_ransac_based_on_feature_matching( source_down, target_down, source_fpfh, target_fpfh, mutual_filter=True, max_correspondence_distance=0.15, estimation_method=o3d.pipelines.registration.TransformationEstimationPointToPoint(False), ransac_n=4, checkers=[o3d.pipelines.registration.CorrespondenceCheckerBasedOnEdgeLength(0.9), o3d.pipelines.registration.CorrespondenceCheckerBasedOnDistance(0.15)], criteria=o3d.pipelines.registration.RANSACConvergenceCriteria(4000000, 500)) print(result_ransac) # 可视化配准前的点云 source_temp = source_down.transform(np.identity(4)) # 恢复原始位置 o3d.visualization.draw_geometries([source_temp, target_down], window_name=\"配准前\") # 可视化配准后的点云 source_temp = source_down.transform(result_ransac.transformation) o3d.visualization.draw_geometries([source_temp, target_down], window_name=\"配准后\")  代码说明：   生成点云数据：创建一个球体点云，并对目标点云进行随机变换。 下采样点云：对点云进行体素下采样，以减少计算量。 估计法线：计算点云的法线。 计算FPFH特征：计算快速点特征直方图（FPFH）特征。 使用RANSAC进行全局配准：使用 RANSAC 算法基于特征匹配进行全局配准。 可视化配准前的点云：在配准前显示源点云和目标点云。 可视化配准后的点云：在配准后显示源点云和目标点云。     初始点云 配准点云                  10.4 多路配准 说明：用于将多个点云配准到一个共同的参考框架中。\nimport open3d as o3d import numpy as np def create_colored_sphere(radius, color, density=1000): mesh = o3d.geometry.TriangleMesh.create_sphere(radius=radius) pcd = mesh.sample_points_poisson_disk(number_of_points=density) pcd.paint_uniform_color(color) return pcd def preprocess_point_cloud(pcd, voxel_size): pcd_down = pcd.voxel_down_sample(voxel_size) radius_normal = voxel_size * 2 pcd_down.estimate_normals(o3d.geometry.KDTreeSearchParamHybrid(radius=radius_normal, max_nn=30)) radius_feature = voxel_size * 5 pcd_fpfh = o3d.pipelines.registration.compute_fpfh_feature( pcd_down, o3d.geometry.KDTreeSearchParamHybrid(radius=radius_feature, max_nn=100)) return pcd_down, pcd_fpfh def pairwise_registration(source, target, voxel_size): source_down, source_fpfh = preprocess_point_cloud(source, voxel_size) target_down, target_fpfh = preprocess_point_cloud(target, voxel_size) distance_threshold = voxel_size * 1.5 result = o3d.pipelines.registration.registration_ransac_based_on_feature_matching( source_down, target_down, source_fpfh, target_fpfh, True, distance_threshold, o3d.pipelines.registration.TransformationEstimationPointToPoint(False), 4, [ o3d.pipelines.registration.CorrespondenceCheckerBasedOnEdgeLength(0.9), o3d.pipelines.registration.CorrespondenceCheckerBasedOnDistance(distance_threshold) ], o3d.pipelines.registration.RANSACConvergenceCriteria(4000000, 500)) return result def full_registration(pcds, voxel_size): pose_graph = o3d.pipelines.registration.PoseGraph() odometry = np.identity(4) pose_graph.nodes.append(o3d.pipelines.registration.PoseGraphNode(odometry)) for source_id in range(len(pcds)): for target_id in range(source_id + 1, len(pcds)): result = pairwise_registration(pcds[source_id], pcds[target_id], voxel_size) trans = result.transformation information = o3d.pipelines.registration.get_information_matrix_from_point_clouds( pcds[source_id], pcds[target_id], voxel_size * 1.5, result.transformation) if target_id == source_id + 1: odometry = np.dot(trans, odometry) pose_graph.nodes.append(o3d.pipelines.registration.PoseGraphNode(np.linalg.inv(odometry))) pose_graph.edges.append(o3d.pipelines.registration.PoseGraphEdge(source_id, target_id, trans, information, uncertain=False)) else: pose_graph.edges.append(o3d.pipelines.registration.PoseGraphEdge(source_id, target_id, trans, information, uncertain=True)) return pose_graph def run_global_optimization(pose_graph): option = o3d.pipelines.registration.GlobalOptimizationOption( max_correspondence_distance=0.02, edge_prune_threshold=0.25, reference_node=0) o3d.pipelines.registration.global_optimization( pose_graph, o3d.pipelines.registration.GlobalOptimizationLevenbergMarquardt(), o3d.pipelines.registration.GlobalOptimizationConvergenceCriteria(), option) def merge_point_clouds(pcds, pose_graph): pcd_combined = o3d.geometry.PointCloud() for point_id in range(len(pcds)): pcd_transformed = pcds[point_id].transform(pose_graph.nodes[point_id].pose) pcd_combined += pcd_transformed return pcd_combined # 创建不同颜色和大小的球体 sphere1 = create_colored_sphere(1.0, [1, 0, 0], density=1000) # 红色球体 sphere2 = create_colored_sphere(0.8, [0, 1, 0], density=1000) # 绿色球体 sphere3 = create_colored_sphere(0.6, [0, 0, 1], density=1000) # 蓝色球体 # 对球体进行随机变换 transformation1 = np.array([[0.862, 0.011, -0.507, 0.5], [-0.139, 0.967, -0.215, 0.7], [0.487, 0.255, 0.835, -1.4], [0.0, 0.0, 0.0, 1.0]]) sphere2.transform(transformation1) transformation2 = np.array([[0.707, -0.707, 0.0, 1.0], [0.707, 0.707, 0.0, 0.5], [0.0, 0.0, 1.0, -0.5], [0.0, 0.0, 0.0, 1.0]]) sphere3.transform(transformation2) pcds = [sphere1, sphere2, sphere3] # 设置体素大小 voxel_size = 0.05 # 可视化配准前的点云 print(\"配准前的点云\") o3d.visualization.draw_geometries(pcds, window_name=\"Before Registration\") # 进行多路配准 pose_graph = full_registration(pcds, voxel_size) # 运行全局优化 run_global_optimization(pose_graph) # 合并点云 pcd_combined = merge_point_clouds(pcds, pose_graph) # 可视化配准后的点云 print(\"配准后的点云\") o3d.visualization.draw_geometries([pcd_combined], window_name=\"After Registration\")  代码说明：   创建彩色球体：使用 create_colored_sphere 函数创建不同颜色和大小的球体。 对球体进行变换：对第二个和第三个球体进行随机变换。 预处理点云：使用 preprocess_point_cloud 函数对点云进行下采样和特征提取。 配对配准：使用 pairwise_registration 函数对两个点云进行配对配准。 全局配准：使用 full_registration 函数对所有点云进行全局配准，构建位姿图。 全局优化：使用 run_global_optimization 函数对位姿图进行全局优化。 合并点云：使用 merge_point_clouds 函数将所有点云合并到一个全局坐标系中。 可视化配准前的点云：使用 Open3D 的可视化工具显示配准前的点云。 可视化配准后的点云：使用 Open3D 的可视化工具显示配准后的点云。     原始点云 配准点云                  这些案例展示了 Open3D 中不同点云配准方法的基本用法。\n11. 点云表面重建 11.1 Alpha形状重建 Alpha形状重建是一种用于从点云数据生成三角网格的方法。它基于计算几何中的Alpha形状理论。Alpha形状是由Edelsbrunner等人在1983年提出的，它是Delaunay三角剖分的一个子集，用于描述点集的形状。\n11.1.1 原理   Delaunay三角剖分：\n 首先，对点云进行Delaunay三角剖分。Delaunay三角剖分是一种将点集划分为一系列三角形的算法，具有最大化最小角的性质，避免了瘦长三角形。    Alpha球：\n 对于给定的参数α，定义一个半径为α的球（称为Alpha球）。Alpha球用于筛选Delaunay三角剖分中的三角形。    筛选三角形：\n 对于每个Delaunay三角剖分中的三角形，检查其外接圆的半径。如果外接圆的半径小于或等于α，则保留该三角形；否则，丢弃该三角形。    生成Alpha形状：\n 保留的三角形构成了Alpha形状。通过调整α的值，可以控制生成的形状的细节程度。较小的α值会生成更细致的形状，而较大的α值会生成更平滑的形状。    11.1.2 代码示例 以下是使用Open3D库进行Alpha形状重建的代码示例：\nimport open3d as o3d # 读取点云 pcd = o3d.io.read_point_cloud(\"doll_1.ply\") # 估计法线 pcd.estimate_normals(search_param=o3d.geometry.KDTreeSearchParamHybrid(radius=0.1, max_nn=30)) # Alpha形状重建 alpha = 0.03 # 调整alpha值 mesh_alpha = o3d.geometry.TriangleMesh.create_from_point_cloud_alpha_shape(pcd, alpha) # 可视化Alpha形状重建结果 mesh_alpha.compute_vertex_normals() o3d.visualization.draw_geometries([mesh_alpha], window_name=f\"Alpha Shape Reconstruction with alpha={alpha}\") 11.1.3 调整Alpha值 通过调整alpha值，可以生成不同细节程度的形状：\n 较小的alpha值：生成的形状更细致，保留更多的细节。 较大的alpha值：生成的形状更平滑，去除了更多的细节。  11.1.4 总结 Alpha形状重建是一种有效的从点云数据生成三角网格的方法，通过调整alpha值，可以控制生成形状的细节程度。它在计算几何和计算机图形学中有广泛的应用。\nimport open3d as o3d # 读取点云 pcd = o3d.io.read_point_cloud(\"doll_1.ply\") # 估计法线 pcd.estimate_normals(search_param=o3d.geometry.KDTreeSearchParamHybrid(radius=0.1, max_nn=30)) # 调整Alpha形状重建参数 print(\"调整Alpha形状重建参数...\") alphas = [0.01, 0.03, 0.05] for alpha in alphas: mesh_alpha = o3d.geometry.TriangleMesh.create_from_point_cloud_alpha_shape(pcd, alpha) mesh_alpha.compute_vertex_normals() title = f\"Alpha Shape Reconstruction with alpha={alpha}\" print(title) o3d.visualization.draw_geometries([mesh_alpha], window_name=title)       \n11.2 泊松重建 泊松重建（Poisson Surface Reconstruction）是一种从点云数据生成平滑三角网格的方法。它基于泊松方程，通过全局优化的方法生成表面，能够有效处理噪声和不完整的点云数据。\n11.2.1 原理   法线估计：\n 首先，从点云数据中估计每个点的法线方向。这一步通常使用邻域搜索算法，如KD树搜索。    泊松方程： 泊松重建的核心是求解泊松方程。泊松方程是一种偏微分方程，形式为：\n  $$ \\nabla \\cdot \\mathbf{V} = \\rho $$\n其中，$\\mathbf{V}$ 是一个向量场，$\\rho$ 是一个标量场。在泊松重建中，$\\mathbf{V}$ 是由点云的法线生成的向量场，$\\rho$ 是点云的散度。\n 构建八叉树：\n 为了高效地求解泊松方程，使用八叉树（Octree）对点云进行分层表示。八叉树将空间递归地划分为八个子空间，直到达到指定的深度。    求解泊松方程：\n 在八叉树的每个节点上，求解泊松方程。通过最小二乘法或其他数值方法，计算出每个节点的标量场值。    提取等值面：\n 使用Marching Cubes算法从标量场中提取等值面，生成三角网格。等值面是标量场中具有相同值的点的集合。    平滑和优化：\n 对生成的三角网格进行平滑和优化，以去除噪声和不规则性，生成最终的平滑表面。    11.2.2 代码示例 以下是使用Open3D库进行泊松重建的代码示例：\nimport open3d as o3d # 读取点云 pcd = o3d.io.read_point_cloud(\"doll_1.ply\") # 估计法线 pcd.estimate_normals(search_param=o3d.geometry.KDTreeSearchParamHybrid(radius=0.1, max_nn=30)) # 泊松重建 depth = 9 # 调整深度参数 mesh_poisson, densities = o3d.geometry.TriangleMesh.create_from_point_cloud_poisson(pcd, depth=depth) # 可视化泊松重建结果 mesh_poisson.compute_vertex_normals() o3d.visualization.draw_geometries([mesh_poisson], window_name=f\"Poisson Reconstruction with depth={depth}\")   \n11.2.3 调整深度参数 通过调整深度参数，可以控制生成的网格的细节程度：\n 较小的深度值：生成的网格较粗糙，计算速度较快。 较大的深度值：生成的网格较细致，计算速度较慢。  11.2.4 总结 泊松重建是一种从点云数据生成平滑三角网格的有效方法。它通过求解泊松方程，能够处理噪声和不完整的点云数据，生成高质量的表面。通过调整深度参数，可以控制生成网格的细节程度。\n12. 最小包围盒 使用Open3D计算点云的包围盒可以通过以下两种方式：轴对齐包围盒（Axis-Aligned Bounding Box, AABB）和有向包围盒（Oriented Bounding Box, OBB）。 下面是一个示例代码，展示如何计算和可视化这两种包围盒。\n 示例代码  import open3d as o3d # 读取点云 pcd = o3d.io.read_point_cloud(\"doll_1.ply\") # 计算轴对齐包围盒（AABB） aabb = pcd.get_axis_aligned_bounding_box() # 计算有向包围盒（OBB） obb = pcd.get_oriented_bounding_box() # 设置包围盒的颜色 aabb.color = (1, 0, 0) # 红色 obb.color = (0, 1, 0) # 绿色 # 可视化点云和包围盒 o3d.visualization.draw_geometries([pcd, aabb, obb], window_name=\"Bounding Boxes\")   \n 说明    读取点云：\n 使用 o3d.io.read_point_cloud 函数读取点云数据。    计算轴对齐包围盒（AABB）：\n 使用 pcd.get_axis_aligned_bounding_box() 方法计算点云的轴对齐包围盒。AABB是一个与坐标轴对齐的最小包围盒。    计算有向包围盒（OBB）：\n 使用 pcd.get_oriented_bounding_box() 方法计算点云的有向包围盒。OBB是一个最小体积的包围盒，可以任意旋转。    设置包围盒的颜色：\n 通过设置 color 属性来改变包围盒的颜色，以便在可视化时区分不同的包围盒。    可视化点云和包围盒：\n 使用 o3d.visualization.draw_geometries 函数同时可视化点云和包围盒。     总结  通过上述代码，可以使用Open3D计算点云的轴对齐包围盒和有向包围盒，并进行可视化。这对于点云数据的分析和处理非常有用。\n13. 凸包 使用Open3D计算点云的凸包可以通过 compute_convex_hull 方法来实现。 以下是一个示例代码，展示如何计算和可视化点云的凸包。\n 示例代码  import open3d as o3d # 读取点云 pcd = o3d.io.read_point_cloud(\"doll_1.ply\") # 计算凸包 hull, _ = pcd.compute_convex_hull() # 设置凸包的颜色 hull.paint_uniform_color([1, 0, 0]) # 红色 # 可视化点云和凸包 o3d.visualization.draw_geometries([pcd, hull], window_name=\"Convex Hull\")   \n 说明    读取点云：\n 使用 o3d.io.read_point_cloud 函数读取点云数据。    计算凸包：\n 使用 pcd.compute_convex_hull() 方法计算点云的凸包。该方法返回一个三角网格表示的凸包和一个索引数组（这里我们只关心凸包）。    设置凸包的颜色：\n 使用 hull.paint_uniform_color([1, 0, 0]) 方法将凸包的颜色设置为红色，以便在可视化时区分凸包和点云。    可视化点云和凸包：\n 使用 o3d.visualization.draw_geometries 函数同时可视化点云和凸包。      总结\n 通过上述代码，可以使用Open3D计算点云的凸包，并进行可视化。这对于点云数据的分析和处理非常有用，特别是在需要了解点云的外部形状时。    14. 体素化 使用Open3D计算点云的体素化可以通过 voxel_down_sample 方法来实现。体素化是将点云划分为固定大小的立方体（体素），并用每个体素内的点的中心点来代表该体素。 以下是一个示例代码，展示如何对点云进行体素化处理并进行可视化。\n 示例代码  import open3d as o3d # 读取点云 pcd = o3d.io.read_point_cloud(\"doll_1.ply\") # 设置体素大小 voxel_size = 0.05 # 进行体素化 voxel_grid = o3d.geometry.VoxelGrid.create_from_point_cloud(pcd, voxel_size=voxel_size) # 可视化原始点云和体素化后的点云 o3d.visualization.draw_geometries([pcd], window_name=\"Original Point Cloud\") o3d.visualization.draw_geometries([voxel_grid], window_name=\"Voxelized Point Cloud\")     \n 说明    读取点云：\n 使用 o3d.io.read_point_cloud 函数读取点云数据。    设置体素大小：\n 定义体素的大小（例如 voxel_size = 0.05），该值决定了每个体素的边长。    进行体素化：\n 使用 o3d.geometry.VoxelGrid.create_from_point_cloud(pcd, voxel_size=voxel_size) 方法对点云进行体素化处理。该方法返回一个 VoxelGrid 对象，表示体素化后的点云。    可视化原始点云和体素化后的点云：\n 使用 o3d.visualization.draw_geometries 函数分别可视化原始点云和体素化后的点云。      总结\n 通过上述代码，可以使用Open3D对点云进行体素化处理，并进行可视化。体素化处理可以有效地减少点云数据的数量，同时保留点云的整体结构，对于点云数据的分析和处理非常有用。    ","wordCount":"3885","inLanguage":"zh-cn","image":"https://chase6305.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-03-04T00:00:00Z","dateModified":"2025-03-04T00:00:00Z","author":{"@type":"Person","name":"Chase"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://chase6305.github.io/posts/open3d/introduction/"},"publisher":{"@type":"Organization","name":"Chase Blog","logo":{"@type":"ImageObject","url":"https://chase6305.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href=https://chase6305.github.io/ accesskey=h title="Chase's Home (Alt + H)"><img src=https://chase6305.github.io/apple-touch-icon.png alt aria-label=logo height=35>Chase's Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://chase6305.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://chase6305.github.io/archives/ title=archives><span>archives</span></a></li><li><a href=https://chase6305.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://chase6305.github.io/>Home</a></div><h1 class="post-title entry-hint-parent">Open3D 教程学习指南 (持续整理)</h1><div class=post-meta><span title="2025-03-04 00:00:00 +0000 UTC">2025-03-04</span>&nbsp;·&nbsp;Chase&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/open3d/introduction/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#11-主要功能>1.1 主要功能</a></li></ul><ul><li><a href=#21-安装-open3d>2.1 安装 Open3D</a><ul><li><a href=#方法一通过-pip-安装>方法一：通过 pip 安装</a></li><li><a href=#方法二手动安装>方法二：手动安装</a></li><li><a href=#方法三安装-cpu-版本>方法三：安装 CPU 版本</a></li><li><a href=#方法四源码安装>方法四：源码安装</a></li></ul></li><li><a href=#22-第三方库管理>2.2 第三方库管理</a></li><li><a href=#23-编译原理>2.3 编译原理</a></li></ul><ul><li><a href=#31-点云写入文件>3.1 点云写入文件</a></li><li><a href=#32-读取点云文件>3.2 读取点云文件</a></li><li><a href=#33-可视化点云>3.3 可视化点云</a></li><li><a href=#34-使用案例>3.4 使用案例</a></li></ul><ul><li><a href=#41-支持的读取文件格式>4.1 支持的读取文件格式</a></li><li><a href=#42-支持的写入文件格式>4.2 支持的写入文件格式</a></li><li><a href=#43-trianglemesh-读取>4.3 TriangleMesh 读取</a></li><li><a href=#44-从mesh上提取点云>4.4 从mesh上提取点云</a></li></ul><ul><li><a href=#51-kd-树-说明与算法原理>5.1 KD-树 说明与算法原理</a><ul><li><a href=#511-kd-树的简介>5.1.1 KD-树的简介</a></li><li><a href=#512-kd-树的构建>5.1.2 KD-树的构建</a></li><li><a href=#513-kd-树的搜索>5.1.3 KD-树的搜索</a></li><li><a href=#514-kd-树的插入>5.1.4 KD-树的插入</a></li><li><a href=#515-kd-树的应用>5.1.5 KD-树的应用</a></li><li><a href=#516-kd-树的c实现>5.1.6 KD-树的C++实现</a></li></ul></li><li><a href=#52-kdtreeflann接口>5.2 KDTreeFlann接口</a></li><li><a href=#53-open3d-中-k-d-树的接口案例>5.3 Open3D 中 k-d 树的接口案例</a></li></ul><ul><li><a href=#61-基本原理>6.1 基本原理</a><ul><li><a href=#611-构建八叉树>6.1.1 构建八叉树</a></li><li><a href=#612-节点结构>6.1.2 节点结构</a></li><li><a href=#613-空间划分>6.1.3 空间划分</a></li></ul></li><li><a href=#62-应用>6.2 应用</a><ul><li><a href=#621-空间划分>6.2.1 空间划分</a></li><li><a href=#622-最近邻搜索>6.2.2 最近邻搜索</a></li><li><a href=#623-碰撞检测>6.2.3 碰撞检测</a></li><li><a href=#624-空间索引>6.2.4 空间索引</a></li></ul></li><li><a href=#63-实现细节>6.3 实现细节</a><ul><li><a href=#631-插入元素>6.3.1 插入元素</a></li><li><a href=#632-查找元素>6.3.2 查找元素</a></li><li><a href=#633-删除元素>6.3.3 删除元素</a></li></ul></li><li><a href=#64-优缺点>6.4 优缺点</a><ul><li><a href=#641-优点>6.4.1 优点</a></li><li><a href=#642-缺点>6.4.2 缺点</a></li></ul></li><li><a href=#64-open3d-octree>6.4 Open3D Octree</a><ul><li><a href=#641-构建-octree>6.4.1 构建 Octree</a></li><li><a href=#642-从点云构建-octree>6.4.2 从点云构建 Octree</a></li><li><a href=#643-插入点>6.4.3 插入点</a></li><li><a href=#644-查询点>6.4.4 查询点</a></li><li><a href=#645-可视化-octree>6.4.5 可视化 Octree</a></li><li><a href=#646-完整示例代码>6.4.6 完整示例代码</a></li><li><a href=#647-点云分割>6.4.7 点云分割</a></li></ul></li></ul><ul><li><a href=#81-transform应用变换矩阵到点云>8.1 <strong>transform</strong>：应用变换矩阵到点云</a></li><li><a href=#82-translate平移点云>8.2 <strong>translate</strong>：平移点云</a></li><li><a href=#83-rotate旋转点云>8.3 <strong>rotate</strong>：旋转点云</a></li><li><a href=#84-scale缩放点云>8.4 <strong>scale</strong>：缩放点云</a></li></ul><ul><li><a href=#91-estimate_normals估计点云法线>9.1 <strong>estimate_normals</strong>：估计点云法线</a></li><li><a href=#92-orient_normals_consistent_tangent_plane使法线方向一致>9.2 <strong>orient_normals_consistent_tangent_plane</strong>：使法线方向一致</a></li><li><a href=#93-详细案例>9.3 详细案例</a></li></ul><ul><li><a href=#101-icp-配准>10.1 ICP 配准</a></li><li><a href=#102-colored-icp-配准>10.2 Colored ICP 配准</a></li><li><a href=#103-全局配准>10.3 全局配准</a></li><li><a href=#104-多路配准>10.4 多路配准</a></li></ul><ul><li><a href=#111-alpha形状重建>11.1 Alpha形状重建</a><ul><li><a href=#1111-原理>11.1.1 原理</a></li><li><a href=#1112-代码示例>11.1.2 代码示例</a></li><li><a href=#1113-调整alpha值>11.1.3 调整Alpha值</a></li><li><a href=#1114-总结>11.1.4 总结</a></li></ul></li><li><a href=#112-泊松重建>11.2 泊松重建</a><ul><li><a href=#1121-原理>11.2.1 原理</a></li><li><a href=#1122-代码示例>11.2.2 代码示例</a></li><li><a href=#1123-调整深度参数>11.2.3 调整深度参数</a></li><li><a href=#1124-总结>11.2.4 总结</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>本章仅为个人学习整理。</p><p>Open3D: <a href=https://www.open3d.org/>https://www.open3d.org/</a>
Github repo: <a href=https://github.com/isl-org/Open3D>https://github.com/isl-org/Open3D</a></p><h1 id=1-概述>1. 概述<a hidden class=anchor aria-hidden=true href=#1-概述>#</a></h1><p>Open3D 是一个开源库，旨在为 3D 数据处理提供高效且易用的工具。它由 Intel 开发和维护，支持多种 3D 数据处理任务，如点云处理、3D 重建、几何处理和可视化等。</p><h2 id=11-主要功能>1.1 主要功能<a hidden class=anchor aria-hidden=true href=#11-主要功能>#</a></h2><ul><li>点云处理：<ul><li>支持点云的读取、写入和可视化。</li><li>提供点云滤波、配准、分割和特征提取等功能。</li></ul></li><li>3D 重建：<ul><li>支持从深度图像生成 3D 网格。</li><li>提供多视图 3D 重建算法。</li></ul></li><li>几何处理：<ul><li>支持对三角网格、体素网格和曲面的处理。</li><li>提供几何变换、简化和布尔运算等功能。</li></ul></li><li>可视化：<ul><li>提供交互式的 3D 可视化工具。</li><li>支持点云、网格和体素的渲染。</li></ul></li><li>机器学习：<ul><li>提供与深度学习框架的集成，支持 3D 数据的机器学习任务。<figure><img src=open3d.png alt=open3d loading=lazy></figure></li></ul></li></ul><h1 id=2-安装>2. 安装<a hidden class=anchor aria-hidden=true href=#2-安装>#</a></h1><h2 id=21-安装-open3d>2.1 安装 Open3D<a hidden class=anchor aria-hidden=true href=#21-安装-open3d>#</a></h2><h3 id=方法一通过-pip-安装>方法一：通过 pip 安装<a hidden class=anchor aria-hidden=true href=#方法一通过-pip-安装>#</a></h3><p>可以直接使用 pip 安装 Open3D：</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>pip install open3d
</code></pre></div><h3 id=方法二手动安装>方法二：手动安装<a hidden class=anchor aria-hidden=true href=#方法二手动安装>#</a></h3><p>你也可以从 <a href=https://pypi.org/project/open3d/0.18.0/#description>PyPI</a> 下载对应版本的 <code>.whl</code> 文件，然后手动安装。例如，对于 Linux x86 系统和 Python 3.9 环境：</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>pip install open3d-0.18.0-cp39-cp39-manylinux_2_27_x86_64.whl
</code></pre></div><h3 id=方法三安装-cpu-版本>方法三：安装 CPU 版本<a hidden class=anchor aria-hidden=true href=#方法三安装-cpu-版本>#</a></h3><p>如果不使用 NVIDIA 的 CUDA，可以考虑安装 CPU 版本：</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>pip install open3d-cpu
</code></pre></div><h3 id=方法四源码安装>方法四：源码安装<a hidden class=anchor aria-hidden=true href=#方法四源码安装>#</a></h3><p>你也可以从源码安装 Open3D。具体步骤可以参考 <a href=http://www.open3d.org/docs/release/compilation.html>Open3D 的官方文档</a>。</p><h2 id=22-第三方库管理>2.2 第三方库管理<a hidden class=anchor aria-hidden=true href=#22-第三方库管理>#</a></h2><p>Open3D 使用 CMake 来管理第三方库。CMake 是一个跨平台的构建系统，它可以帮助自动化软件构建过程，包括查找和配置第三方库。Open3D 通过 CMake 的 <code>find_package</code> 和 <code>ExternalProject</code> 模块来管理第三方库。</p><ul><li><strong>第三方库管理步骤</strong></li></ul><ol><li><p><strong>查找系统库</strong>：</p><ul><li>Open3D 使用 <code>find_package</code> 命令查找系统中已经安装的库。例如，查找 Eigen 库：<div class=highlight><pre class=chroma><code class=language-cmake data-lang=cmake><span class=nb>find_package</span><span class=p>(</span><span class=s>Eigen3</span> <span class=s>REQUIRED</span><span class=p>)</span><span class=err>
</span><span class=err></span><span class=nb>include_directories</span><span class=p>(</span><span class=o>${</span><span class=nv>EIGEN3_INCLUDE_DIR</span><span class=o>}</span><span class=p>)</span><span class=err>
</span></code></pre></div></li></ul></li><li><p><strong>下载和构建外部项目</strong>：</p><ul><li>对于一些没有预安装的库，Open3D 使用 <code>ExternalProject_Add</code> 命令从源代码下载并构建这些库。例如，下载并构建 GLFW：<div class=highlight><pre class=chroma><code class=language-cmake data-lang=cmake><span class=nb>include</span><span class=p>(</span><span class=s>ExternalProject</span><span class=p>)</span><span class=err>
</span><span class=err></span><span class=nb>ExternalProject_Add</span><span class=p>(</span><span class=s>glfw</span>
  <span class=s>GIT_REPOSITORY</span> <span class=s>https://github.com/glfw/glfw.git</span>
  <span class=s>GIT_TAG</span> <span class=s>latest</span>
  <span class=s>CMAKE_ARGS</span> <span class=s>-DCMAKE_INSTALL_PREFIX=</span><span class=o>${</span><span class=nv>CMAKE_BINARY_DIR</span><span class=o>}</span><span class=s>/third_party_install</span>
<span class=p>)</span><span class=err>
</span></code></pre></div></li></ul></li><li><p><strong>使用 <code>third_party</code> 目录</strong>：</p><ul><li>Open3D 在其源代码中包含了一些第三方库的副本，这些库存放在 <code>third_party</code> 目录下。CMakeLists.txt 文件会配置这些库的构建和链接。例如，配置和使用 Filament 库：<div class=highlight><pre class=chroma><code class=language-cmake data-lang=cmake><span class=nb>add_subdirectory</span><span class=p>(</span><span class=s>third_party/filament</span><span class=p>)</span><span class=err>
</span><span class=err></span><span class=nb>include_directories</span><span class=p>(</span><span class=s>third_party/filament/include</span><span class=p>)</span><span class=err>
</span></code></pre></div></li></ul></li></ol><p>Open3D 通过 CMake 的 <code>find_package</code> 和 <code>ExternalProject_Add</code> 命令来查找和管理第三方库，并使用 <code>third_party</code> 目录包含一些必要的库。这样可以确保在不同平台上都能顺利构建和运行 Open3D。</p><h2 id=23-编译原理>2.3 编译原理<a hidden class=anchor aria-hidden=true href=#23-编译原理>#</a></h2><ol><li><p><strong>CMake 配置</strong>：</p><ul><li>Open3D 使用 CMake 作为构建系统。CMakeLists.txt 文件定义了项目的构建配置，包括源文件、依赖项、编译选项等。</li><li>CMake 会生成适合目标平台的构建文件（如 Makefile 或 Visual Studio 项目文件）。</li></ul></li><li><p><strong>依赖项管理</strong>：</p><ul><li>Open3D 依赖多个第三方库，如 Eigen（用于线性代数计算）、GLFW（用于窗口管理）、Pybind11（用于 Python 绑定）等。</li><li>CMake 会自动查找和配置这些依赖项。</li></ul></li><li><p><strong>编译和链接</strong>：</p><ul><li>CMake 生成的构建文件会调用编译器（如 GCC 或 Clang）编译源代码，并链接生成目标文件（如库或可执行文件）。</li><li>编译过程中会根据配置选项启用或禁用某些功能模块。</li></ul></li><li><p><strong>Python 绑定</strong>：</p><ul><li>如果启用了 Python 绑定，Open3D 会使用 Pybind11 生成 Python 模块，使得 Open3D 可以在 Python 中使用。</li><li>编译过程中会生成 <code>_pybind</code> 模块，并将其安装到 Python 的包目录中。</li></ul></li></ol><h1 id=3-点云写入读取可视化>3. 点云写入、读取、可视化<a hidden class=anchor aria-hidden=true href=#3-点云写入读取可视化>#</a></h1><p><code>open3d.io.write_point_cloud</code> 是一个用于将点云数据写入文件的函数。
<code>open3d.io.read_point_cloud</code> 是一个用于从文件中读取点云数据的函数。
<code>open3d.visualization.draw_geometries</code> 是一个用于可视化几何对象列表的函数。</p><h2 id=31-点云写入文件>3.1 点云写入文件<a hidden class=anchor aria-hidden=true href=#31-点云写入文件>#</a></h2><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>open3d</span><span class=o>.</span><span class=n>io</span><span class=o>.</span><span class=n>write_point_cloud</span><span class=p>(</span>
    <span class=n>filename</span><span class=p>:</span> <span class=n>os</span><span class=o>.</span><span class=n>PathLike</span><span class=p>,</span> 
    <span class=n>pointcloud</span><span class=p>:</span> <span class=n>open3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>PointCloud</span><span class=p>,</span> 
    <span class=n>format</span><span class=p>:</span> <span class=nb>str</span> <span class=o>=</span> <span class=s1>&#39;auto&#39;</span><span class=p>,</span> 
    <span class=n>write_ascii</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=bp>False</span><span class=p>,</span> 
    <span class=n>compressed</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=bp>False</span><span class=p>,</span> 
    <span class=n>print_progress</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=bp>False</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>bool</span>
</code></pre></div><p>参数说明
<code>filename (os.PathLike)</code>：文件路径。
<code>pointcloud (open3d.geometry.PointCloud)</code>：要写入的 PointCloud 对象。
<code>format (str, optional, default='auto')</code>：输出文件的格式。当未指定或设置为 auto 时，格式将从文件扩展名推断。
<code>write_ascii (bool, optional, default=False)</code>：如果为 True，则以 ASCII 格式输出，否则使用二进制格式。
<code>compressed (bool, optional, default=False)</code>：如果为 True，则以压缩格式写入。
<code>print_progress (bool, optional, default=False)</code>：如果为 True，在控制台中显示进度条。</p><h2 id=32-读取点云文件>3.2 读取点云文件<a hidden class=anchor aria-hidden=true href=#32-读取点云文件>#</a></h2><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>open3d</span><span class=o>.</span><span class=n>io</span><span class=o>.</span><span class=n>read_point_cloud</span><span class=p>(</span>
    <span class=n>filename</span><span class=p>:</span> <span class=n>os</span><span class=o>.</span><span class=n>PathLike</span><span class=p>,</span> 
    <span class=n>format</span><span class=p>:</span> <span class=nb>str</span> <span class=o>=</span> <span class=s1>&#39;auto&#39;</span><span class=p>,</span> 
    <span class=n>remove_nan_points</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=bp>False</span><span class=p>,</span> 
    <span class=n>remove_infinite_points</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=bp>False</span><span class=p>,</span> 
    <span class=n>print_progress</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=bp>False</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=n>open3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>PointCloud</span>
</code></pre></div><p>参数说明
<code>filename (os.PathLike)</code>：文件路径。
<code>format (str, optional, default='auto')</code>：输入文件的格式。当未指定或设置为 auto 时，格式将从文件扩展名推断。
<code>remove_nan_points (bool, optional, default=False)</code>：如果为 True，则移除包含 NaN 值的点。
<code>remove_infinite_points (bool, optional, default=False)</code>：如果为 True，则移除包含无限值的点。
<code>print_progress (bool, optional, default=False)</code>：如果为 True，在控制台中显示进度条。</p><h2 id=33-可视化点云>3.3 可视化点云<a hidden class=anchor aria-hidden=true href=#33-可视化点云>#</a></h2><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>open3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>(</span>
    <span class=n>geometry_list</span><span class=p>:</span> <span class=nb>list</span><span class=p>[</span><span class=n>open3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>Geometry</span><span class=p>],</span> 
    <span class=n>window_name</span><span class=p>:</span> <span class=nb>str</span> <span class=o>=</span> <span class=s1>&#39;Open3D&#39;</span><span class=p>,</span> 
    <span class=n>width</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>1920</span><span class=p>,</span> 
    <span class=n>height</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>1080</span><span class=p>,</span> 
    <span class=n>left</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>50</span><span class=p>,</span> 
    <span class=n>top</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>50</span><span class=p>,</span> 
    <span class=n>point_show_normal</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=bp>False</span><span class=p>,</span> 
    <span class=n>mesh_show_wireframe</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=bp>False</span><span class=p>,</span> 
    <span class=n>mesh_show_back_face</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=bp>False</span><span class=p>,</span> 
    <span class=n>lookat</span><span class=p>:</span> <span class=n>numpy</span><span class=o>.</span><span class=n>ndarray</span><span class=p>[</span><span class=n>numpy</span><span class=o>.</span><span class=n>float64</span><span class=p>[</span><span class=mi>3</span><span class=p>,</span> <span class=mi>1</span><span class=p>]]</span> <span class=o>|</span> <span class=bp>None</span> <span class=o>=</span> <span class=bp>None</span><span class=p>,</span> 
    <span class=n>up</span><span class=p>:</span> <span class=n>numpy</span><span class=o>.</span><span class=n>ndarray</span><span class=p>[</span><span class=n>numpy</span><span class=o>.</span><span class=n>float64</span><span class=p>[</span><span class=mi>3</span><span class=p>,</span> <span class=mi>1</span><span class=p>]]</span> <span class=o>|</span> <span class=bp>None</span> <span class=o>=</span> <span class=bp>None</span><span class=p>,</span> 
    <span class=n>front</span><span class=p>:</span> <span class=n>numpy</span><span class=o>.</span><span class=n>ndarray</span><span class=p>[</span><span class=n>numpy</span><span class=o>.</span><span class=n>float64</span><span class=p>[</span><span class=mi>3</span><span class=p>,</span> <span class=mi>1</span><span class=p>]]</span> <span class=o>|</span> <span class=bp>None</span> <span class=o>=</span> <span class=bp>None</span><span class=p>,</span> 
    <span class=n>zoom</span><span class=p>:</span> <span class=nb>float</span> <span class=o>|</span> <span class=bp>None</span> <span class=o>=</span> <span class=bp>None</span>
<span class=p>)</span> <span class=o>-&gt;</span> <span class=bp>None</span>
</code></pre></div><p>参数说明
<code>geometry_list (list[open3d.geometry.Geometry])</code>：要可视化的几何对象列表。
<code>window_name (str, optional, default='Open3D')</code>：可视化窗口的标题。
<code>width (int, optional, default=1920)</code>：可视化窗口的宽度。
<code>height (int, optional, default=1080)</code>：可视化窗口的高度。
<code>left (int, optional, default=50)</code>：可视化窗口的左边距。
<code>top (int, optional, default=50)</code>：可视化窗口的上边距。
<code>point_show_normal (bool, optional, default=False)</code>：如果为 True，则显示点的法线。
<code>mesh_show_wireframe (bool, optional, default=False)</code>：如果为 True，则显示网格的线框。
<code>mesh_show_back_face (bool, optional, default=False)</code>：如果为 True，则显示网格三角形的背面。
<code>lookat (Optional[numpy.ndarray[numpy.float64[3, 1]]], optional, default=None)</code>：相机的 lookat 向量。
<code>up (Optional[numpy.ndarray[numpy.float64[3, 1]]], optional, default=None)</code>：相机的 up 向量。
<code>front (Optional[numpy.ndarray[numpy.float64[3, 1]]], optional, default=None)</code>：相机的 front 向量。
<code>zoom (Optional[float], optional, default=None)</code>：相机的缩放。</p><h2 id=34-使用案例>3.4 使用案例<a hidden class=anchor aria-hidden=true href=#34-使用案例>#</a></h2><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>open3d</span> <span class=kn>as</span> <span class=nn>o3d</span>
<span class=kn>import</span> <span class=nn>numpy</span> <span class=kn>as</span> <span class=nn>np</span>

<span class=c1># 生成一个简单的点云（例如，一个立方体的顶点）</span>
<span class=n>points</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span>
    <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>],</span>
    <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>],</span>
    <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>],</span>
    <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>],</span>
    <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>],</span>
    <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>],</span>
    <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>],</span>
    <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>],</span>
<span class=p>])</span>

<span class=c1># 创建 PointCloud 对象</span>
<span class=n>pcd</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>PointCloud</span><span class=p>()</span>

<span class=c1># 将点添加到 PointCloud 对象中</span>
<span class=n>pcd</span><span class=o>.</span><span class=n>points</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>utility</span><span class=o>.</span><span class=n>Vector3dVector</span><span class=p>(</span><span class=n>points</span><span class=p>)</span>

<span class=c1># 保存点云到文件</span>
<span class=n>o3d</span><span class=o>.</span><span class=n>io</span><span class=o>.</span><span class=n>write_point_cloud</span><span class=p>(</span><span class=s2>&#34;generated_point_cloud.ply&#34;</span><span class=p>,</span> <span class=n>pcd</span><span class=p>)</span>

<span class=c1># 读取点云文件</span>
<span class=n>load_pcd</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>io</span><span class=o>.</span><span class=n>read_point_cloud</span><span class=p>(</span><span class=s2>&#34;generated_point_cloud.ply&#34;</span><span class=p>)</span>

<span class=c1># 可视化点云</span>
<span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>([</span><span class=n>load_pcd</span><span class=p>])</span>
</code></pre></div><p><figure><img src=cude_pc.png alt=cude_pc loading=lazy></figure></p><h1 id=4-trianglemesh-读取保存>4. TriangleMesh 读取、保存<a hidden class=anchor aria-hidden=true href=#4-trianglemesh-读取保存>#</a></h1><p><strong>TriangleMeshIO</strong>节选代码: <a href=https://github.com/isl-org/Open3D/blob/main/cpp/open3d/io/TriangleMeshIO.cpp>https://github.com/isl-org/Open3D/blob/main/cpp/open3d/io/TriangleMeshIO.cpp</a></p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>static</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span>
        <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span>
        <span class=n>std</span><span class=o>::</span><span class=n>function</span><span class=o>&lt;</span><span class=kt>bool</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=p>,</span>
                           <span class=n>geometry</span><span class=o>::</span><span class=n>TriangleMesh</span> <span class=o>&amp;</span><span class=p>,</span>
                           <span class=k>const</span> <span class=n>ReadTriangleMeshOptions</span> <span class=o>&amp;</span><span class=p>)</span><span class=o>&gt;&gt;</span>
        <span class=n>file_extension_to_trianglemesh_read_function</span><span class=p>{</span>
                <span class=p>{</span><span class=s>&#34;ply&#34;</span><span class=p>,</span> <span class=n>ReadTriangleMeshFromPLY</span><span class=p>},</span>
                <span class=p>{</span><span class=s>&#34;stl&#34;</span><span class=p>,</span> <span class=n>ReadTriangleMeshUsingASSIMP</span><span class=p>},</span>
                <span class=p>{</span><span class=s>&#34;obj&#34;</span><span class=p>,</span> <span class=n>ReadTriangleMeshUsingASSIMP</span><span class=p>},</span>
                <span class=p>{</span><span class=s>&#34;off&#34;</span><span class=p>,</span> <span class=n>ReadTriangleMeshFromOFF</span><span class=p>},</span>
                <span class=p>{</span><span class=s>&#34;gltf&#34;</span><span class=p>,</span> <span class=n>ReadTriangleMeshUsingASSIMP</span><span class=p>},</span>
                <span class=p>{</span><span class=s>&#34;glb&#34;</span><span class=p>,</span> <span class=n>ReadTriangleMeshUsingASSIMP</span><span class=p>},</span>
                <span class=p>{</span><span class=s>&#34;fbx&#34;</span><span class=p>,</span> <span class=n>ReadTriangleMeshUsingASSIMP</span><span class=p>},</span>
        <span class=p>};</span>

<span class=k>static</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span>
        <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span>
        <span class=n>std</span><span class=o>::</span><span class=n>function</span><span class=o>&lt;</span><span class=kt>bool</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=p>,</span>
                           <span class=k>const</span> <span class=n>geometry</span><span class=o>::</span><span class=n>TriangleMesh</span> <span class=o>&amp;</span><span class=p>,</span>
                           <span class=k>const</span> <span class=kt>bool</span><span class=p>,</span>
                           <span class=k>const</span> <span class=kt>bool</span><span class=p>,</span>
                           <span class=k>const</span> <span class=kt>bool</span><span class=p>,</span>
                           <span class=k>const</span> <span class=kt>bool</span><span class=p>,</span>
                           <span class=k>const</span> <span class=kt>bool</span><span class=p>,</span>
                           <span class=k>const</span> <span class=kt>bool</span><span class=p>)</span><span class=o>&gt;&gt;</span>
        <span class=n>file_extension_to_trianglemesh_write_function</span><span class=p>{</span>
                <span class=p>{</span><span class=s>&#34;ply&#34;</span><span class=p>,</span> <span class=n>WriteTriangleMeshToPLY</span><span class=p>},</span>
                <span class=p>{</span><span class=s>&#34;stl&#34;</span><span class=p>,</span> <span class=n>WriteTriangleMeshToSTL</span><span class=p>},</span>
                <span class=p>{</span><span class=s>&#34;obj&#34;</span><span class=p>,</span> <span class=n>WriteTriangleMeshToOBJ</span><span class=p>},</span>
                <span class=p>{</span><span class=s>&#34;off&#34;</span><span class=p>,</span> <span class=n>WriteTriangleMeshToOFF</span><span class=p>},</span>
                <span class=p>{</span><span class=s>&#34;gltf&#34;</span><span class=p>,</span> <span class=n>WriteTriangleMeshToGLTF</span><span class=p>},</span>
                <span class=p>{</span><span class=s>&#34;glb&#34;</span><span class=p>,</span> <span class=n>WriteTriangleMeshToGLTF</span><span class=p>},</span>
        <span class=p>};</span>

<span class=p>}</span>  <span class=c1>// unnamed namespace
</span></code></pre></div><p>在这段代码中，<code>open3d</code> 使用 <code>assimp</code> 来读取和写入多种三角网格文件格式。以下是支持的文件格式：</p><h2 id=41-支持的读取文件格式>4.1 支持的读取文件格式<a hidden class=anchor aria-hidden=true href=#41-支持的读取文件格式>#</a></h2><ul><li><code>ply</code> (使用 <code>ReadTriangleMeshFromPLY</code> 函数)</li><li><code>stl</code> (使用 <code>ReadTriangleMeshUsingASSIMP</code> 函数)</li><li><code>obj</code> (使用 <code>ReadTriangleMeshUsingASSIMP</code> 函数)</li><li><code>off</code> (使用 <code>ReadTriangleMeshFromOFF</code> 函数)</li><li><code>gltf</code> (使用 <code>ReadTriangleMeshUsingASSIMP</code> 函数)</li><li><code>glb</code> (使用 <code>ReadTriangleMeshUsingASSIMP</code> 函数)</li><li><code>fbx</code> (使用 <code>ReadTriangleMeshUsingASSIMP</code> 函数)</li></ul><h2 id=42-支持的写入文件格式>4.2 支持的写入文件格式<a hidden class=anchor aria-hidden=true href=#42-支持的写入文件格式>#</a></h2><ul><li><code>ply</code> (使用 <code>WriteTriangleMeshToPLY</code> 函数)</li><li><code>stl</code> (使用 <code>WriteTriangleMeshToSTL</code> 函数)</li><li><code>obj</code> (使用 <code>WriteTriangleMeshToOBJ</code> 函数)</li><li><code>off</code> (使用 <code>WriteTriangleMeshToOFF</code> 函数)</li><li><code>gltf</code> (使用 <code>WriteTriangleMeshToGLTF</code> 函数)</li><li><code>glb</code> (使用 <code>WriteTriangleMeshToGLTF</code> 函数)</li></ul><p>这些函数通过文件扩展名与相应的读取和写入函数进行映射，从而支持多种三角网格文件格式的读写操作。</p><h2 id=43-trianglemesh-读取>4.3 TriangleMesh 读取<a hidden class=anchor aria-hidden=true href=#43-trianglemesh-读取>#</a></h2><p><code>open3d.io.read_triangle_mesh</code></p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>open3d</span><span class=o>.</span><span class=n>io</span><span class=o>.</span><span class=n>read_triangle_mesh</span><span class=p>(</span>
<span class=n>filename</span><span class=p>:</span> <span class=n>os</span><span class=o>.</span><span class=n>PathLike</span><span class=p>,</span> 
<span class=n>enable_post_processing</span><span class=p>:</span> 
<span class=nb>bool</span> <span class=o>=</span> <span class=bp>False</span><span class=p>,</span> 
<span class=n>print_progress</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=bp>False</span>
<span class=p>)</span> <span class=err>→</span> <span class=n>open3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>TriangleMesh</span>
</code></pre></div><p>参数说明
<code>filename</code>：文件路径，类型为 os.PathLike。
<code>enable_post_processing</code>：是否启用后处理，类型为 bool，默认值为 False。
<code>print_progress</code>：是否在控制台显示进度条，类型为 bool，默认值为 False。</p><p><figure><img src=triangle_mesh.jpeg alt=triangle_mesh loading=lazy></figure></p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>open3d</span> <span class=kn>as</span> <span class=nn>o3d</span>

<span class=c1># 定义文件路径</span>
<span class=n>filename</span> <span class=o>=</span> <span class=s2>&#34;doll.stl&#34;</span>

<span class=k>try</span><span class=p>:</span>
    <span class=c1># 尝试读取三角网格</span>
    <span class=n>mesh</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>io</span><span class=o>.</span><span class=n>read_triangle_mesh</span><span class=p>(</span><span class=n>filename</span><span class=p>,</span> <span class=n>enable_post_processing</span><span class=o>=</span><span class=bp>True</span><span class=p>,</span> <span class=n>print_progress</span><span class=o>=</span><span class=bp>True</span><span class=p>)</span>
    
    <span class=c1># 检查网格是否成功读取</span>
    <span class=k>if</span> <span class=n>mesh</span><span class=o>.</span><span class=n>is_empty</span><span class=p>():</span>
        <span class=k>print</span><span class=p>(</span><span class=s2>&#34;Failed to read the mesh. The file format may not be supported.&#34;</span><span class=p>)</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=k>print</span><span class=p>(</span><span class=s2>&#34;Successfully read the mesh.&#34;</span><span class=p>)</span>
        <span class=c1># 可视化三角网格</span>
        <span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>([</span><span class=n>mesh</span><span class=p>])</span>
<span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
    <span class=k>print</span><span class=p>(</span><span class=n>f</span><span class=s2>&#34;An error occurred: {e}&#34;</span><span class=p>)</span>
</code></pre></div><p><figure><img src=triangle_mesh_1.png alt=triangle_mesh_1 loading=lazy></figure>此时因为没有计算法线, 可视化出来的模型会涂成统一的灰色
然后我们可以<code>compute_vertex_normals</code>来计算出法线信息</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>open3d</span> <span class=kn>as</span> <span class=nn>o3d</span>
<span class=kn>import</span> <span class=nn>numpy</span> <span class=kn>as</span> <span class=nn>np</span>

<span class=c1># 定义文件路径</span>
<span class=n>filename</span> <span class=o>=</span> <span class=s2>&#34;doll.stl&#34;</span>

<span class=c1># 读取三角网格</span>
<span class=n>mesh</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>io</span><span class=o>.</span><span class=n>read_triangle_mesh</span><span class=p>(</span><span class=n>filename</span><span class=p>,</span> <span class=n>enable_post_processing</span><span class=o>=</span><span class=bp>True</span><span class=p>,</span> <span class=n>print_progress</span><span class=o>=</span><span class=bp>True</span><span class=p>)</span>

<span class=c1># 检查网格是否成功读取</span>
<span class=k>if</span> <span class=n>mesh</span><span class=o>.</span><span class=n>is_empty</span><span class=p>():</span>
    <span class=k>print</span><span class=p>(</span><span class=s2>&#34;Failed to read the mesh. The file format may not be supported.&#34;</span><span class=p>)</span>
<span class=k>else</span><span class=p>:</span>
    <span class=k>print</span><span class=p>(</span><span class=s2>&#34;Successfully read the mesh.&#34;</span><span class=p>)</span>
    
    <span class=c1># 计算法线</span>
    <span class=n>mesh</span><span class=o>.</span><span class=n>compute_vertex_normals</span><span class=p>()</span>
    
    <span class=c1># 设置网格的颜色为红色</span>
    <span class=n>mesh</span><span class=o>.</span><span class=n>paint_uniform_color</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>])</span>  <span class=c1># 设置为红色</span>

    <span class=c1># 创建一个可视化窗口</span>
    <span class=n>vis</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>Visualizer</span><span class=p>()</span>
    <span class=n>vis</span><span class=o>.</span><span class=n>create_window</span><span class=p>()</span>

    <span class=c1># 添加网格到可视化窗口</span>
    <span class=n>vis</span><span class=o>.</span><span class=n>add_geometry</span><span class=p>(</span><span class=n>mesh</span><span class=p>)</span>

    <span class=c1># 更新几何体和渲染器</span>
    <span class=n>vis</span><span class=o>.</span><span class=n>update_geometry</span><span class=p>(</span><span class=n>mesh</span><span class=p>)</span>
    <span class=n>vis</span><span class=o>.</span><span class=n>poll_events</span><span class=p>()</span>
    <span class=n>vis</span><span class=o>.</span><span class=n>update_renderer</span><span class=p>()</span>

    <span class=c1># 渲染</span>
    <span class=n>vis</span><span class=o>.</span><span class=n>run</span><span class=p>()</span>
    <span class=n>vis</span><span class=o>.</span><span class=n>destroy_window</span><span class=p>()</span>

</code></pre></div><p><figure><img src=triangle_mesh_2.png alt=triangle_mesh_2 loading=lazy></figure></p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>open3d</span> <span class=kn>as</span> <span class=nn>o3d</span>
<span class=kn>import</span> <span class=nn>numpy</span> <span class=kn>as</span> <span class=nn>np</span>

<span class=c1># 定义文件路径</span>
<span class=n>filename</span> <span class=o>=</span> <span class=s2>&#34;doll.stl&#34;</span>

<span class=c1># 读取三角网格</span>
<span class=n>mesh</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>io</span><span class=o>.</span><span class=n>read_triangle_mesh</span><span class=p>(</span><span class=n>filename</span><span class=p>)</span>
<span class=k>if</span> <span class=n>mesh</span><span class=o>.</span><span class=n>is_empty</span><span class=p>():</span>
    <span class=k>print</span><span class=p>(</span><span class=s2>&#34;Failed to read the mesh. The file format may not be supported.&#34;</span><span class=p>)</span>
<span class=k>else</span><span class=p>:</span>
    <span class=k>print</span><span class=p>(</span><span class=s2>&#34;Successfully read the mesh.&#34;</span><span class=p>)</span>

    <span class=c1># 计算法线</span>
    <span class=n>mesh</span><span class=o>.</span><span class=n>compute_vertex_normals</span><span class=p>()</span>

    <span class=c1># 设置材质</span>
    <span class=n>mat_box</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>rendering</span><span class=o>.</span><span class=n>MaterialRecord</span><span class=p>()</span>
    <span class=n>mat_box</span><span class=o>.</span><span class=n>shader</span> <span class=o>=</span> <span class=s1>&#39;defaultLitSSR&#39;</span>
    <span class=n>mat_box</span><span class=o>.</span><span class=n>base_color</span> <span class=o>=</span> <span class=p>[</span><span class=mf>0.467</span><span class=p>,</span> <span class=mf>0.467</span><span class=p>,</span> <span class=mf>0.467</span><span class=p>,</span> <span class=mf>0.2</span><span class=p>]</span>  <span class=c1># 设置透明度为0.2</span>
    <span class=n>mat_box</span><span class=o>.</span><span class=n>base_roughness</span> <span class=o>=</span> <span class=mf>0.0</span>
    <span class=n>mat_box</span><span class=o>.</span><span class=n>base_reflectance</span> <span class=o>=</span> <span class=mf>0.0</span>
    <span class=n>mat_box</span><span class=o>.</span><span class=n>base_clearcoat</span> <span class=o>=</span> <span class=mf>1.0</span>
    <span class=n>mat_box</span><span class=o>.</span><span class=n>thickness</span> <span class=o>=</span> <span class=mf>1.0</span>
    <span class=n>mat_box</span><span class=o>.</span><span class=n>transmission</span> <span class=o>=</span> <span class=mf>1.0</span>
    <span class=n>mat_box</span><span class=o>.</span><span class=n>absorption_distance</span> <span class=o>=</span> <span class=mi>10</span>
    <span class=n>mat_box</span><span class=o>.</span><span class=n>absorption_color</span> <span class=o>=</span> <span class=p>[</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>]</span>

    <span class=c1># 使用draw函数渲染</span>
    <span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw</span><span class=p>(</span>
        <span class=p>[{</span><span class=s1>&#39;name&#39;</span><span class=p>:</span> <span class=s1>&#39;box&#39;</span><span class=p>,</span> <span class=s1>&#39;geometry&#39;</span><span class=p>:</span> <span class=n>mesh</span><span class=p>,</span> <span class=s1>&#39;material&#39;</span><span class=p>:</span> <span class=n>mat_box</span><span class=p>}],</span>
        <span class=n>show_skybox</span><span class=o>=</span><span class=bp>False</span><span class=p>,</span>
        <span class=n>width</span><span class=o>=</span><span class=mi>800</span><span class=p>,</span>
        <span class=n>height</span><span class=o>=</span><span class=mi>600</span><span class=p>,</span>
        <span class=n>bg_color</span><span class=o>=</span><span class=p>[</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.8</span><span class=p>]</span>  <span class=c1># 设置背景颜色为灰色</span>
    <span class=p>)</span>
</code></pre></div><p><figure><img src=triangle_mesh_3.png alt=triangle_mesh_3 loading=lazy></figure></p><h2 id=44-从mesh上提取点云>4.4 从mesh上提取点云<a hidden class=anchor aria-hidden=true href=#44-从mesh上提取点云>#</a></h2><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>open3d</span> <span class=kn>as</span> <span class=nn>o3d</span>
<span class=kn>import</span> <span class=nn>numpy</span> <span class=kn>as</span> <span class=nn>np</span>

<span class=c1># 定义文件路径</span>
<span class=n>filename</span> <span class=o>=</span> <span class=s2>&#34;doll.stl&#34;</span>

<span class=c1># 读取三角网格</span>
<span class=n>mesh</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>io</span><span class=o>.</span><span class=n>read_triangle_mesh</span><span class=p>(</span><span class=n>filename</span><span class=p>)</span>
<span class=k>if</span> <span class=n>mesh</span><span class=o>.</span><span class=n>is_empty</span><span class=p>():</span>
    <span class=k>print</span><span class=p>(</span><span class=s2>&#34;Failed to read the mesh. The file format may not be supported.&#34;</span><span class=p>)</span>
<span class=k>else</span><span class=p>:</span>
    <span class=k>print</span><span class=p>(</span><span class=s2>&#34;Successfully read the mesh.&#34;</span><span class=p>)</span>

    <span class=c1># 计算法线</span>
    <span class=n>mesh</span><span class=o>.</span><span class=n>compute_vertex_normals</span><span class=p>()</span>

    <span class=c1># 从mesh提取点云</span>
    <span class=n>point_cloud</span> <span class=o>=</span> <span class=n>mesh</span><span class=o>.</span><span class=n>sample_points_uniformly</span><span class=p>(</span><span class=n>number_of_points</span><span class=o>=</span><span class=mi>10000</span><span class=p>)</span>

    <span class=c1># 设置材质</span>
    <span class=n>mat_box</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>rendering</span><span class=o>.</span><span class=n>MaterialRecord</span><span class=p>()</span>
    <span class=n>mat_box</span><span class=o>.</span><span class=n>shader</span> <span class=o>=</span> <span class=s1>&#39;defaultLitSSR&#39;</span>
    <span class=n>mat_box</span><span class=o>.</span><span class=n>base_color</span> <span class=o>=</span> <span class=p>[</span><span class=mf>0.467</span><span class=p>,</span> <span class=mf>0.467</span><span class=p>,</span> <span class=mf>0.467</span><span class=p>,</span> <span class=mf>0.2</span><span class=p>]</span>  <span class=c1># 设置透明度为0.2</span>
    <span class=n>mat_box</span><span class=o>.</span><span class=n>base_roughness</span> <span class=o>=</span> <span class=mf>0.0</span>
    <span class=n>mat_box</span><span class=o>.</span><span class=n>base_reflectance</span> <span class=o>=</span> <span class=mf>0.0</span>
    <span class=n>mat_box</span><span class=o>.</span><span class=n>base_clearcoat</span> <span class=o>=</span> <span class=mf>1.0</span>
    <span class=n>mat_box</span><span class=o>.</span><span class=n>thickness</span> <span class=o>=</span> <span class=mf>1.0</span>
    <span class=n>mat_box</span><span class=o>.</span><span class=n>transmission</span> <span class=o>=</span> <span class=mf>1.0</span>
    <span class=n>mat_box</span><span class=o>.</span><span class=n>absorption_distance</span> <span class=o>=</span> <span class=mi>10</span>
    <span class=n>mat_box</span><span class=o>.</span><span class=n>absorption_color</span> <span class=o>=</span> <span class=p>[</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>]</span>

    <span class=c1># 使用draw函数渲染</span>
    <span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw</span><span class=p>(</span>
        <span class=p>[{</span><span class=s1>&#39;name&#39;</span><span class=p>:</span> <span class=s1>&#39;box&#39;</span><span class=p>,</span> <span class=s1>&#39;geometry&#39;</span><span class=p>:</span> <span class=n>mesh</span><span class=p>,</span> <span class=s1>&#39;material&#39;</span><span class=p>:</span> <span class=n>mat_box</span><span class=p>},</span>
         <span class=p>{</span><span class=s1>&#39;name&#39;</span><span class=p>:</span> <span class=s1>&#39;point_cloud&#39;</span><span class=p>,</span> <span class=s1>&#39;geometry&#39;</span><span class=p>:</span> <span class=n>point_cloud</span><span class=p>}],</span>
        <span class=n>show_skybox</span><span class=o>=</span><span class=bp>False</span><span class=p>,</span>
        <span class=n>width</span><span class=o>=</span><span class=mi>800</span><span class=p>,</span>
        <span class=n>height</span><span class=o>=</span><span class=mi>600</span><span class=p>,</span>
        <span class=n>bg_color</span><span class=o>=</span><span class=p>[</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.8</span><span class=p>]</span>  <span class=c1># 设置背景颜色为灰色</span>
    <span class=p>)</span>
</code></pre></div><p><figure><img src=triangle_mesh_4.png alt=triangle_mesh_4 loading=lazy></figure></p><h1 id=5-kd-tree>5. KD-Tree<a hidden class=anchor aria-hidden=true href=#5-kd-tree>#</a></h1><h2 id=51-kd-树-说明与算法原理>5.1 KD-树 说明与算法原理<a hidden class=anchor aria-hidden=true href=#51-kd-树-说明与算法原理>#</a></h2><h3 id=511-kd-树的简介>5.1.1 KD-树的简介<a hidden class=anchor aria-hidden=true href=#511-kd-树的简介>#</a></h3><p>KD-树（K-Dimension Tree）是一种用于多维空间数据的搜索数据结构，其构建和搜索过程类似于二叉搜索树，但适用于高维场景。通过交替使用各维特征进行划分，KD-树能在 (O(\log N)) 的时间复杂度内实现最近邻搜索。此外，它还支持动态插入新节点，通过一种类似替罪羊树的方法保持一定的结构平衡，确保插入效率。
另外, 可以直接看wiki的说明:
<a href=https://en.wikipedia.org/wiki/K-d_tree>https://en.wikipedia.org/wiki/K-d_tree</a></p><h3 id=512-kd-树的构建>5.1.2 KD-树的构建<a hidden class=anchor aria-hidden=true href=#512-kd-树的构建>#</a></h3><p>KD-树的构建过程如下：</p><ol><li><strong>选择分割维度</strong>：从根节点开始，依次选择各维度进行分割。通常选择数据点在该维度上的中位数作为分割点。</li><li><strong>递归构建子树</strong>：将数据点分为两部分，左子树包含小于等于分割点的数据点，右子树包含大于分割点的数据点。递归地对每个子树进行上述操作，直到所有数据点都被处理完。</li></ol><h3 id=513-kd-树的搜索>5.1.3 KD-树的搜索<a hidden class=anchor aria-hidden=true href=#513-kd-树的搜索>#</a></h3><p>KD-树的搜索过程如下：</p><ol><li><strong>递归搜索</strong>：从根节点开始，根据查询点在当前分割维度上的值，递归地搜索左子树或右子树。</li><li><strong>回溯检查</strong>：在回溯过程中，检查当前节点是否比已找到的最近邻更接近查询点。如果是，则更新最近邻。</li><li><strong>检查其他子树</strong>：如果查询点与当前分割平面的距离小于已找到的最近邻距离，则需要检查另一个子树。</li></ol><h3 id=514-kd-树的插入>5.1.4 KD-树的插入<a hidden class=anchor aria-hidden=true href=#514-kd-树的插入>#</a></h3><p>KD-树的插入过程如下：</p><ol><li><strong>找到插入位置</strong>：从根节点开始，递归地找到适合插入新节点的位置。</li><li><strong>插入新节点</strong>：在找到的插入位置插入新节点，并根据需要调整树的结构以保持平衡。</li></ol><h3 id=515-kd-树的应用>5.1.5 KD-树的应用<a hidden class=anchor aria-hidden=true href=#515-kd-树的应用>#</a></h3><p>KD-树广泛应用于以下场景：</p><ol><li><strong>最近邻搜索</strong>：在点云处理、图像检索等领域，KD-树可以高效地找到距离查询点最近的点。</li><li><strong>范围查询</strong>：在地理信息系统中，KD-树可以用于查找指定范围内的所有点。</li><li><strong>聚类分析</strong>：在机器学习中，KD-树可以用于加速 K-means 聚类算法。</li></ol><h3 id=516-kd-树的c实现>5.1.6 KD-树的C++实现<a hidden class=anchor aria-hidden=true href=#516-kd-树的c实现>#</a></h3><p>以下是一个简单的 KD-树的 C++ 实现示例：</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;algorithm&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=k>struct</span> <span class=nc>Point</span> <span class=p>{</span>
    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span> <span class=n>coords</span><span class=p>;</span>
    <span class=n>Point</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>initializer_list</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span> <span class=n>init</span><span class=p>)</span> <span class=o>:</span> <span class=n>coords</span><span class=p>(</span><span class=n>init</span><span class=p>)</span> <span class=p>{}</span>
<span class=p>};</span>

<span class=k>struct</span> <span class=nc>KDNode</span> <span class=p>{</span>
    <span class=n>Point</span> <span class=n>point</span><span class=p>;</span>
    <span class=n>KDNode</span><span class=o>*</span> <span class=n>left</span><span class=p>;</span>
    <span class=n>KDNode</span><span class=o>*</span> <span class=n>right</span><span class=p>;</span>
    <span class=n>KDNode</span><span class=p>(</span><span class=n>Point</span> <span class=n>p</span><span class=p>)</span> <span class=o>:</span> <span class=n>point</span><span class=p>(</span><span class=n>p</span><span class=p>),</span> <span class=n>left</span><span class=p>(</span><span class=k>nullptr</span><span class=p>),</span> <span class=n>right</span><span class=p>(</span><span class=k>nullptr</span><span class=p>)</span> <span class=p>{}</span>
<span class=p>};</span>

<span class=k>class</span> <span class=nc>KDTree</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
    <span class=n>KDTree</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Point</span><span class=o>&gt;&amp;</span> <span class=n>points</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>root</span> <span class=o>=</span> <span class=n>build</span><span class=p>(</span><span class=n>points</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=n>KDNode</span><span class=o>*</span> <span class=nf>build</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Point</span><span class=o>&gt;&amp;</span> <span class=n>points</span><span class=p>,</span> <span class=kt>int</span> <span class=n>depth</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>points</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span> <span class=k>return</span> <span class=k>nullptr</span><span class=p>;</span>
        <span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=n>points</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>coords</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
        <span class=kt>int</span> <span class=n>axis</span> <span class=o>=</span> <span class=n>depth</span> <span class=o>%</span> <span class=n>k</span><span class=p>;</span>
        <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Point</span><span class=o>&gt;</span> <span class=n>sorted_points</span> <span class=o>=</span> <span class=n>points</span><span class=p>;</span>
        <span class=n>std</span><span class=o>::</span><span class=n>sort</span><span class=p>(</span><span class=n>sorted_points</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>sorted_points</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=p>[</span><span class=n>axis</span><span class=p>](</span><span class=k>const</span> <span class=n>Point</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>,</span> <span class=k>const</span> <span class=n>Point</span><span class=o>&amp;</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>return</span> <span class=n>a</span><span class=p>.</span><span class=n>coords</span><span class=p>[</span><span class=n>axis</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>b</span><span class=p>.</span><span class=n>coords</span><span class=p>[</span><span class=n>axis</span><span class=p>];</span>
        <span class=p>});</span>
        <span class=kt>int</span> <span class=n>median</span> <span class=o>=</span> <span class=n>sorted_points</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
        <span class=n>KDNode</span><span class=o>*</span> <span class=n>node</span> <span class=o>=</span> <span class=k>new</span> <span class=n>KDNode</span><span class=p>(</span><span class=n>sorted_points</span><span class=p>[</span><span class=n>median</span><span class=p>]);</span>
        <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Point</span><span class=o>&gt;</span> <span class=n>left_points</span><span class=p>(</span><span class=n>sorted_points</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>sorted_points</span><span class=p>.</span><span class=n>begin</span><span class=p>()</span> <span class=o>+</span> <span class=n>median</span><span class=p>);</span>
        <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Point</span><span class=o>&gt;</span> <span class=n>right_points</span><span class=p>(</span><span class=n>sorted_points</span><span class=p>.</span><span class=n>begin</span><span class=p>()</span> <span class=o>+</span> <span class=n>median</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>sorted_points</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>
        <span class=n>node</span><span class=o>-&gt;</span><span class=n>left</span> <span class=o>=</span> <span class=n>build</span><span class=p>(</span><span class=n>left_points</span><span class=p>,</span> <span class=n>depth</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
        <span class=n>node</span><span class=o>-&gt;</span><span class=n>right</span> <span class=o>=</span> <span class=n>build</span><span class=p>(</span><span class=n>right_points</span><span class=p>,</span> <span class=n>depth</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
        <span class=k>return</span> <span class=n>node</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=kt>void</span> <span class=nf>nearestNeighborSearch</span><span class=p>(</span><span class=k>const</span> <span class=n>Point</span><span class=o>&amp;</span> <span class=n>query</span><span class=p>,</span> <span class=n>Point</span><span class=o>&amp;</span> <span class=n>best</span><span class=p>,</span> <span class=kt>double</span><span class=o>&amp;</span> <span class=n>best_dist</span><span class=p>,</span> <span class=n>KDNode</span><span class=o>*</span> <span class=n>node</span><span class=p>,</span> <span class=kt>int</span> <span class=n>depth</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>node</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>
        <span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=n>query</span><span class=p>.</span><span class=n>coords</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
        <span class=kt>int</span> <span class=n>axis</span> <span class=o>=</span> <span class=n>depth</span> <span class=o>%</span> <span class=n>k</span><span class=p>;</span>
        <span class=kt>double</span> <span class=n>dist</span> <span class=o>=</span> <span class=n>distance</span><span class=p>(</span><span class=n>query</span><span class=p>,</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>point</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>dist</span> <span class=o>&lt;</span> <span class=n>best_dist</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>best_dist</span> <span class=o>=</span> <span class=n>dist</span><span class=p>;</span>
            <span class=n>best</span> <span class=o>=</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>point</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=kt>double</span> <span class=n>diff</span> <span class=o>=</span> <span class=n>query</span><span class=p>.</span><span class=n>coords</span><span class=p>[</span><span class=n>axis</span><span class=p>]</span> <span class=o>-</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>point</span><span class=p>.</span><span class=n>coords</span><span class=p>[</span><span class=n>axis</span><span class=p>];</span>
        <span class=n>KDNode</span><span class=o>*</span> <span class=n>near</span> <span class=o>=</span> <span class=n>diff</span> <span class=o>&lt;=</span> <span class=mi>0</span> <span class=o>?</span> <span class=n>node</span><span class=o>-&gt;</span><span class=nl>left</span> <span class=p>:</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>;</span>
        <span class=n>KDNode</span><span class=o>*</span> <span class=n>far</span> <span class=o>=</span> <span class=n>diff</span> <span class=o>&lt;=</span> <span class=mi>0</span> <span class=o>?</span> <span class=n>node</span><span class=o>-&gt;</span><span class=nl>right</span> <span class=p>:</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>;</span>
        <span class=n>nearestNeighborSearch</span><span class=p>(</span><span class=n>query</span><span class=p>,</span> <span class=n>best</span><span class=p>,</span> <span class=n>best_dist</span><span class=p>,</span> <span class=n>near</span><span class=p>,</span> <span class=n>depth</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>abs</span><span class=p>(</span><span class=n>diff</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>best_dist</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>nearestNeighborSearch</span><span class=p>(</span><span class=n>query</span><span class=p>,</span> <span class=n>best</span><span class=p>,</span> <span class=n>best_dist</span><span class=p>,</span> <span class=n>far</span><span class=p>,</span> <span class=n>depth</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=n>Point</span> <span class=nf>nearestNeighbor</span><span class=p>(</span><span class=k>const</span> <span class=n>Point</span><span class=o>&amp;</span> <span class=n>query</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>Point</span> <span class=n>best</span> <span class=o>=</span> <span class=n>root</span><span class=o>-&gt;</span><span class=n>point</span><span class=p>;</span>
        <span class=kt>double</span> <span class=n>best_dist</span> <span class=o>=</span> <span class=n>distance</span><span class=p>(</span><span class=n>query</span><span class=p>,</span> <span class=n>best</span><span class=p>);</span>
        <span class=n>nearestNeighborSearch</span><span class=p>(</span><span class=n>query</span><span class=p>,</span> <span class=n>best</span><span class=p>,</span> <span class=n>best_dist</span><span class=p>,</span> <span class=n>root</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
        <span class=k>return</span> <span class=n>best</span><span class=p>;</span>
    <span class=p>}</span>

<span class=k>private</span><span class=o>:</span>
    <span class=n>KDNode</span><span class=o>*</span> <span class=n>root</span><span class=p>;</span>

    <span class=kt>double</span> <span class=nf>distance</span><span class=p>(</span><span class=k>const</span> <span class=n>Point</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>,</span> <span class=k>const</span> <span class=n>Point</span><span class=o>&amp;</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>double</span> <span class=n>dist</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>a</span><span class=p>.</span><span class=n>coords</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>dist</span> <span class=o>+=</span> <span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>coords</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-</span> <span class=n>b</span><span class=p>.</span><span class=n>coords</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=o>*</span> <span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>coords</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-</span> <span class=n>b</span><span class=p>.</span><span class=n>coords</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
        <span class=p>}</span>
        <span class=k>return</span> <span class=n>dist</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>};</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Point</span><span class=o>&gt;</span> <span class=n>points</span> <span class=o>=</span> <span class=p>{{</span><span class=mf>2.0</span><span class=p>,</span> <span class=mf>3.0</span><span class=p>},</span> <span class=p>{</span><span class=mf>5.0</span><span class=p>,</span> <span class=mf>4.0</span><span class=p>},</span> <span class=p>{</span><span class=mf>9.0</span><span class=p>,</span> <span class=mf>6.0</span><span class=p>},</span> <span class=p>{</span><span class=mf>4.0</span><span class=p>,</span> <span class=mf>7.0</span><span class=p>},</span> <span class=p>{</span><span class=mf>8.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>},</span> <span class=p>{</span><span class=mf>7.0</span><span class=p>,</span> <span class=mf>2.0</span><span class=p>}};</span>
    <span class=n>KDTree</span> <span class=n>tree</span><span class=p>(</span><span class=n>points</span><span class=p>);</span>
    <span class=n>Point</span> <span class=n>query</span> <span class=o>=</span> <span class=p>{</span><span class=mf>9.0</span><span class=p>,</span> <span class=mf>2.0</span><span class=p>};</span>
    <span class=n>Point</span> <span class=n>nearest</span> <span class=o>=</span> <span class=n>tree</span><span class=p>.</span><span class=n>nearestNeighbor</span><span class=p>(</span><span class=n>query</span><span class=p>);</span>
    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;最近邻点: (&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>nearest</span><span class=p>.</span><span class=n>coords</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;, &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>nearest</span><span class=p>.</span><span class=n>coords</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p><strong>KD-树</strong>是一种高效的多维空间数据搜索结构，适用于最近邻搜索、范围查询和聚类分析等场景。通过交替使用各维特征进行划分，KD-树能在 (O(\log N)) 的时间复杂度内实现高效搜索。</p><h2 id=52-kdtreeflann接口>5.2 KDTreeFlann接口<a hidden class=anchor aria-hidden=true href=#52-kdtreeflann接口>#</a></h2><p>Open3D 提供了 <code>KDTreeFlann</code> 类，用于高效的空间查询。主要的接口包括：</p><ul><li><p><strong>search_knn_vector_3d</strong>：最近邻搜索</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=p>[</span><span class=n>k</span><span class=p>,</span> <span class=n>idx</span><span class=p>,</span> <span class=n>dist</span><span class=p>]</span> <span class=o>=</span> <span class=n>kdtree</span><span class=o>.</span><span class=n>search_knn_vector_3d</span><span class=p>(</span><span class=n>query_point</span><span class=p>,</span> <span class=n>k</span><span class=p>)</span>
</code></pre></div><ul><li><code>query_point</code>：查询点</li><li><code>k</code>：返回最近邻的数量</li><li>返回值：<code>k</code> 为找到的邻居数量，<code>idx</code> 为邻居的索引，<code>dist</code> 为邻居的距离</li></ul></li><li><p><strong>search_radius_vector_3d</strong>：半径搜索</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=p>[</span><span class=n>k</span><span class=p>,</span> <span class=n>idx</span><span class=p>,</span> <span class=n>dist</span><span class=p>]</span> <span class=o>=</span> <span class=n>kdtree</span><span class=o>.</span><span class=n>search_radius_vector_3d</span><span class=p>(</span><span class=n>query_point</span><span class=p>,</span> <span class=n>radius</span><span class=p>)</span>
</code></pre></div><ul><li><code>query_point</code>：查询点</li><li><code>radius</code>：搜索半径</li><li>返回值：<code>k</code> 为找到的邻居数量，<code>idx</code> 为邻居的索引，<code>dist</code> 为邻居的距离</li></ul></li><li><p><strong>search_hybrid_vector_3d</strong>：固定距离搜索</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=p>[</span><span class=n>k</span><span class=p>,</span> <span class=n>idx</span><span class=p>,</span> <span class=n>dist</span><span class=p>]</span> <span class=o>=</span> <span class=n>kdtree</span><span class=o>.</span><span class=n>search_hybrid_vector_3d</span><span class=p>(</span><span class=n>query_point</span><span class=p>,</span> <span class=n>radius</span><span class=p>,</span> <span class=n>max_nn</span><span class=p>)</span>
</code></pre></div><ul><li><code>query_point</code>：查询点</li><li><code>radius</code>：搜索半径</li><li><code>max_nn</code>：返回的最大邻居数量</li><li>返回值：<code>k</code> 为找到的邻居数量，<code>idx</code> 为邻居的索引，<code>dist</code> 为邻居的距离</li></ul></li></ul><h2 id=53-open3d-中-k-d-树的接口案例>5.3 Open3D 中 k-d 树的接口案例<a hidden class=anchor aria-hidden=true href=#53-open3d-中-k-d-树的接口案例>#</a></h2><p>以下是使用 Open3D 构建和查询 k-d 树的示例代码：</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>open3d</span> <span class=kn>as</span> <span class=nn>o3d</span>
<span class=kn>import</span> <span class=nn>numpy</span> <span class=kn>as</span> <span class=nn>np</span>

<span class=c1># 创建一个随机点云</span>
<span class=n>pcd</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>PointCloud</span><span class=p>()</span>
<span class=n>pcd</span><span class=o>.</span><span class=n>points</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>utility</span><span class=o>.</span><span class=n>Vector3dVector</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>rand</span><span class=p>(</span><span class=mi>5000</span><span class=p>,</span> <span class=mi>3</span><span class=p>))</span>

<span class=c1># 为点云设置颜色</span>
<span class=n>colors</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>rand</span><span class=p>(</span><span class=mi>5000</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>  <span class=c1># 随机颜色</span>
<span class=n>pcd</span><span class=o>.</span><span class=n>colors</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>utility</span><span class=o>.</span><span class=n>Vector3dVector</span><span class=p>(</span><span class=n>colors</span><span class=p>)</span>

<span class=c1># 构建k-d tree</span>
<span class=n>kdtree</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>KDTreeFlann</span><span class=p>(</span><span class=n>pcd</span><span class=p>)</span>

<span class=c1># 查询k-d tree中的最近邻</span>
<span class=n>query_point</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>rand</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
<span class=p>[</span><span class=n>k</span><span class=p>,</span> <span class=n>idx</span><span class=p>,</span> <span class=n>dist</span><span class=p>]</span> <span class=o>=</span> <span class=n>kdtree</span><span class=o>.</span><span class=n>search_knn_vector_3d</span><span class=p>(</span><span class=n>query_point</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span>
<span class=k>print</span><span class=p>(</span><span class=s2>&#34;查询点:&#34;</span><span class=p>,</span> <span class=n>query_point</span><span class=p>)</span>
<span class=k>print</span><span class=p>(</span><span class=s2>&#34;k-d tree最近邻索引:&#34;</span><span class=p>,</span> <span class=n>idx</span><span class=p>)</span>
<span class=k>print</span><span class=p>(</span><span class=s2>&#34;k-d tree最近邻距离:&#34;</span><span class=p>,</span> <span class=n>dist</span><span class=p>)</span>

<span class=c1># 提取最近邻点</span>
<span class=n>nearest_points</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>asarray</span><span class=p>(</span><span class=n>pcd</span><span class=o>.</span><span class=n>points</span><span class=p>)[</span><span class=n>idx</span><span class=p>,</span> <span class=p>:]</span>

<span class=c1># 创建查询点和最近邻点的点云</span>
<span class=n>query_pcd</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>PointCloud</span><span class=p>()</span>
<span class=n>query_pcd</span><span class=o>.</span><span class=n>points</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>utility</span><span class=o>.</span><span class=n>Vector3dVector</span><span class=p>([</span><span class=n>query_point</span><span class=p>])</span>
<span class=n>query_pcd</span><span class=o>.</span><span class=n>paint_uniform_color</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>])</span>  <span class=c1># 将查询点设置为红色</span>

<span class=n>nearest_pcd</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>PointCloud</span><span class=p>()</span>
<span class=n>nearest_pcd</span><span class=o>.</span><span class=n>points</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>utility</span><span class=o>.</span><span class=n>Vector3dVector</span><span class=p>(</span><span class=n>nearest_points</span><span class=p>)</span>
<span class=n>nearest_pcd</span><span class=o>.</span><span class=n>paint_uniform_color</span><span class=p>([</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>])</span>  <span class=c1># 将最近邻点设置为绿色</span>

<span class=c1># 可视化点云、查询点和最近邻点</span>
<span class=n>vis</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>Visualizer</span><span class=p>()</span>
<span class=n>vis</span><span class=o>.</span><span class=n>create_window</span><span class=p>()</span>
<span class=n>vis</span><span class=o>.</span><span class=n>add_geometry</span><span class=p>(</span><span class=n>pcd</span><span class=p>)</span>
<span class=n>vis</span><span class=o>.</span><span class=n>add_geometry</span><span class=p>(</span><span class=n>query_pcd</span><span class=p>)</span>
<span class=n>vis</span><span class=o>.</span><span class=n>add_geometry</span><span class=p>(</span><span class=n>nearest_pcd</span><span class=p>)</span>

<span class=c1># 调整点云大小</span>
<span class=n>opt</span> <span class=o>=</span> <span class=n>vis</span><span class=o>.</span><span class=n>get_render_option</span><span class=p>()</span>
<span class=n>opt</span><span class=o>.</span><span class=n>point_size</span> <span class=o>=</span> <span class=mf>2.0</span>  <span class=c1># 设置原始点云大小</span>
<span class=n>opt</span><span class=o>.</span><span class=n>background_color</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>asarray</span><span class=p>([</span><span class=mf>0.8</span><span class=p>,</span> <span class=mf>0.8</span><span class=p>,</span> <span class=mf>0.8</span><span class=p>])</span>  <span class=c1># 设置背景颜色</span>

<span class=c1># 放大最近邻点的大小</span>
<span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>nearest_pcd</span><span class=o>.</span><span class=n>points</span><span class=p>)):</span>
    <span class=n>sphere</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>TriangleMesh</span><span class=o>.</span><span class=n>create_sphere</span><span class=p>(</span><span class=n>radius</span><span class=o>=</span><span class=mf>0.02</span><span class=p>)</span>
    <span class=n>sphere</span><span class=o>.</span><span class=n>translate</span><span class=p>(</span><span class=n>nearest_pcd</span><span class=o>.</span><span class=n>points</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
    <span class=n>sphere</span><span class=o>.</span><span class=n>paint_uniform_color</span><span class=p>([</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>])</span>
    <span class=n>vis</span><span class=o>.</span><span class=n>add_geometry</span><span class=p>(</span><span class=n>sphere</span><span class=p>)</span>

<span class=c1># 更新可视化</span>
<span class=n>vis</span><span class=o>.</span><span class=n>poll_events</span><span class=p>()</span>
<span class=n>vis</span><span class=o>.</span><span class=n>update_renderer</span><span class=p>()</span>
<span class=n>vis</span><span class=o>.</span><span class=n>run</span><span class=p>()</span>
<span class=n>vis</span><span class=o>.</span><span class=n>destroy_window</span><span class=p>()</span>
</code></pre></div><p><figure><img src=sphere_1.png alt=sphere_1 loading=lazy></figure></p><ul><li><strong>创建点云</strong>：生成一个包含 1000 个随机点的点云。</li><li><strong>构建 k-d 树</strong>：使用 o3d.geometry.KDTreeFlann 构建 k-d 树。</li><li><strong>查询最近邻</strong>：使用 search_knn_vector_3d 方法查询给定点的 5 个最近邻。</li><li><strong>提取最近邻点</strong>：从点云中提取最近邻点。</li><li><strong>设置颜色</strong>：将原始点云设置为灰色，查询点设置为红色，最近邻点设置为绿色。</li><li><strong>可视化</strong>：将点云、查询点和最近邻点一起可视化。</li></ul><h1 id=6-octree-八叉树>6. Octree 八叉树<a hidden class=anchor aria-hidden=true href=#6-octree-八叉树>#</a></h1><p>Octree 八叉树是一种用于描述三维空间的树状数据结构。它的基本思想是递归地将三维空间划分成更小的体积单元，每个节点表示一个正方体的体积元素，每个节点有八个子节点，将八个子节点所表示的体积元素加在一起就等于父节点的体积。
另外, 可以直接看wiki的说明:
<a href=https://en.wikipedia.org/wiki/Octree>https://en.wikipedia.org/wiki/Octree</a></p><h2 id=61-基本原理>6.1 基本原理<a hidden class=anchor aria-hidden=true href=#61-基本原理>#</a></h2><h3 id=611-构建八叉树>6.1.1 构建八叉树<a hidden class=anchor aria-hidden=true href=#611-构建八叉树>#</a></h3><ol><li><strong>根节点</strong>：八叉树的根节点表示整个三维空间或一个较大的正方体。</li><li><strong>划分空间</strong>：将空间划分为八个相等的子空间，每个子空间对应一个子节点。</li><li><strong>递归划分</strong>：对于每个子节点，如果其包含的元素数量超过预设阈值，则继续递归地将该子节点对应的空间再划分为八个更小的子空间，直到每个子节点包含的元素数量小于或等于阈值，或者达到设定的最大深度。</li></ol><h3 id=612-节点结构>6.1.2 节点结构<a hidden class=anchor aria-hidden=true href=#612-节点结构>#</a></h3><p>每个八叉树节点包含以下信息：</p><ul><li><strong>边界（Boundary）</strong>：定义了节点所代表的空间区域。</li><li><strong>子节点（Children）</strong>：指向八个子节点的指针。</li><li><strong>元素（Elements）</strong>：节点所包含的元素列表，通常是点、物体或其他空间实体。</li></ul><h3 id=613-空间划分>6.1.3 空间划分<a hidden class=anchor aria-hidden=true href=#613-空间划分>#</a></h3><p>在三维空间中，每个节点代表一个正方体，可以通过中心点和边长来定义。将正方体沿三个坐标轴（x、y、z）各切一刀，就可以得到八个子正方体。</p><h2 id=62-应用>6.2 应用<a hidden class=anchor aria-hidden=true href=#62-应用>#</a></h2><h3 id=621-空间划分>6.2.1 空间划分<a hidden class=anchor aria-hidden=true href=#621-空间划分>#</a></h3><p>八叉树常用于三维空间的分层表示和管理，例如在计算机图形学中用于加速光线追踪和碰撞检测。通过将复杂的三维场景划分成更小的区域，可以大大减少需要处理的元素数量，从而提高计算效率。</p><h3 id=622-最近邻搜索>6.2.2 最近邻搜索<a hidden class=anchor aria-hidden=true href=#622-最近邻搜索>#</a></h3><p>在三维空间中查找某个点的最近邻居时，可以利用八叉树快速缩小搜索范围。通过递归地检查包含目标点的节点及其相邻节点，可以高效地找到最近邻居。</p><h3 id=623-碰撞检测>6.2.3 碰撞检测<a hidden class=anchor aria-hidden=true href=#623-碰撞检测>#</a></h3><p>在物理引擎中，八叉树被广泛用于碰撞检测。通过将物体划分到不同的节点中，可以快速确定哪些物体可能发生碰撞，从而减少不必要的碰撞检测计算。</p><h3 id=624-空间索引>6.2.4 空间索引<a hidden class=anchor aria-hidden=true href=#624-空间索引>#</a></h3><p>八叉树也可以用于空间数据库中的空间索引，支持快速的空间查询操作，如范围查询和K近邻查询。</p><h2 id=63-实现细节>6.3 实现细节<a hidden class=anchor aria-hidden=true href=#63-实现细节>#</a></h2><h3 id=631-插入元素>6.3.1 插入元素<a hidden class=anchor aria-hidden=true href=#631-插入元素>#</a></h3><p>将一个元素插入八叉树时，首先找到包含该元素的节点，然后递归地检查该节点是否需要进一步划分，直到找到最适合的叶子节点，将元素插入其中。</p><h3 id=632-查找元素>6.3.2 查找元素<a hidden class=anchor aria-hidden=true href=#632-查找元素>#</a></h3><p>查找元素时，从根节点开始，根据元素的位置递归地进入对应的子节点，直到找到包含该元素的节点。</p><h3 id=633-删除元素>6.3.3 删除元素<a hidden class=anchor aria-hidden=true href=#633-删除元素>#</a></h3><p>删除元素时，首先找到包含该元素的节点，然后从节点的元素列表中删除该元素。如果删除后节点的元素数量小于阈值，则可以考虑合并该节点的子节点以减少树的深度。</p><h2 id=64-优缺点>6.4 优缺点<a hidden class=anchor aria-hidden=true href=#64-优缺点>#</a></h2><h3 id=641-优点>6.4.1 优点<a hidden class=anchor aria-hidden=true href=#641-优点>#</a></h3><ul><li><strong>高效的空间划分</strong>：八叉树可以高效地划分三维空间，适用于处理大规模三维数据。</li><li><strong>快速查询</strong>：支持快速的空间查询操作，如最近邻搜索和碰撞检测。</li><li><strong>灵活性</strong>：可以自适应地划分空间，根据需要调整树的深度和节点容量。</li></ul><h3 id=642-缺点>6.4.2 缺点<a hidden class=anchor aria-hidden=true href=#642-缺点>#</a></h3><ul><li><strong>内存消耗</strong>：在处理大规模数据时，八叉树的节点数量可能非常庞大，导致较高的内存消耗。</li><li><strong>复杂性</strong>：实现和维护八叉树的数据结构相对复杂，特别是在处理动态数据时。</li></ul><p>八叉树是一种强大的数据结构，广泛应用于三维空间的划分和管理。通过递归地将三维空间划分为更小的体积单元，八叉树可以高效地支持各种空间查询操作，如最近邻搜索和碰撞检测。然而，在实际应用中，需要权衡其内存消耗和实现复杂性，以确保其高效性和实用性。</p><h2 id=64-open3d-octree>6.4 Open3D Octree<a hidden class=anchor aria-hidden=true href=#64-open3d-octree>#</a></h2><p><code>Octree</code> 类是 Open3D 中用于三维空间分割的主要类。它提供了构建、插入、查询等功能。</p><h3 id=641-构建-octree>6.4.1 构建 Octree<a hidden class=anchor aria-hidden=true href=#641-构建-octree>#</a></h3><p>要构建一个 Octree，可以使用 <code>Octree</code> 类并指定最大深度：</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>open3d</span> <span class=kn>as</span> <span class=nn>o3d</span>

<span class=c1># 创建一个 Octree，指定最大深度</span>
<span class=n>max_depth</span> <span class=o>=</span> <span class=mi>4</span>
<span class=n>octree</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>Octree</span><span class=p>(</span><span class=n>max_depth</span><span class=p>)</span>
</code></pre></div><h3 id=642-从点云构建-octree>6.4.2 从点云构建 Octree<a hidden class=anchor aria-hidden=true href=#642-从点云构建-octree>#</a></h3><p>可以从一个点云构建 Octree：</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=c1># 创建一个随机点云</span>
<span class=n>pcd</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>PointCloud</span><span class=p>()</span>
<span class=n>pcd</span><span class=o>.</span><span class=n>points</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>utility</span><span class=o>.</span><span class=n>Vector3dVector</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>rand</span><span class=p>(</span><span class=mi>5000</span><span class=p>,</span> <span class=mi>3</span><span class=p>))</span>

<span class=c1># 从点云构建 Octree</span>
<span class=n>octree</span><span class=o>.</span><span class=n>convert_from_point_cloud</span><span class=p>(</span><span class=n>pcd</span><span class=p>,</span> <span class=n>size_expand</span><span class=o>=</span><span class=mf>0.01</span><span class=p>)</span>
</code></pre></div><h3 id=643-插入点>6.4.3 插入点<a hidden class=anchor aria-hidden=true href=#643-插入点>#</a></h3><p>可以向 Octree 中插入单个点：</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>point</span> <span class=o>=</span> <span class=p>[</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>]</span>
<span class=n>octree</span><span class=o>.</span><span class=n>insert_point</span><span class=p>(</span><span class=n>point</span><span class=p>)</span>
</code></pre></div><h3 id=644-查询点>6.4.4 查询点<a hidden class=anchor aria-hidden=true href=#644-查询点>#</a></h3><p>可以查询一个点是否在 Octree 中，并获取其所在的叶节点信息：</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>query_point</span> <span class=o>=</span> <span class=p>[</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>]</span>
<span class=n>success</span><span class=p>,</span> <span class=n>node_info</span> <span class=o>=</span> <span class=n>octree</span><span class=o>.</span><span class=n>locate_leaf_node</span><span class=p>(</span><span class=n>query_point</span><span class=p>)</span>
<span class=k>print</span><span class=p>(</span><span class=s2>&#34;查询成功:&#34;</span><span class=p>,</span> <span class=n>success</span><span class=p>)</span>
<span class=k>print</span><span class=p>(</span><span class=s2>&#34;节点信息:&#34;</span><span class=p>,</span> <span class=n>node_info</span><span class=p>)</span>
</code></pre></div><h3 id=645-可视化-octree>6.4.5 可视化 Octree<a hidden class=anchor aria-hidden=true href=#645-可视化-octree>#</a></h3><p>可以使用 Open3D 的可视化工具来显示 Octree：</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>([</span><span class=n>octree</span><span class=p>])</span>
</code></pre></div><h3 id=646-完整示例代码>6.4.6 完整示例代码<a hidden class=anchor aria-hidden=true href=#646-完整示例代码>#</a></h3><p>以下是一个完整的示例代码，展示了如何构建、插入、查询和可视化 Octree：</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>open3d</span> <span class=kn>as</span> <span class=nn>o3d</span>
<span class=kn>import</span> <span class=nn>numpy</span> <span class=kn>as</span> <span class=nn>np</span>

<span class=c1># 创建一个随机点云</span>
<span class=n>pcd</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>PointCloud</span><span class=p>()</span>
<span class=n>pcd</span><span class=o>.</span><span class=n>points</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>utility</span><span class=o>.</span><span class=n>Vector3dVector</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>rand</span><span class=p>(</span><span class=mi>5000</span><span class=p>,</span> <span class=mi>3</span><span class=p>))</span>

<span class=c1># 构建 Octree</span>
<span class=n>max_depth</span> <span class=o>=</span> <span class=mi>4</span>
<span class=n>octree</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>Octree</span><span class=p>(</span><span class=n>max_depth</span><span class=p>)</span>
<span class=n>octree</span><span class=o>.</span><span class=n>convert_from_point_cloud</span><span class=p>(</span><span class=n>pcd</span><span class=p>,</span> <span class=n>size_expand</span><span class=o>=</span><span class=mf>0.01</span><span class=p>)</span>

<span class=c1># 插入多个点</span>
<span class=n>points</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>rand</span><span class=p>(</span><span class=mi>100</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>  <span class=c1># 生成 100 个随机点</span>

<span class=k>def</span> <span class=nf>leaf_node_init</span><span class=p>():</span>
    <span class=k>return</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>OctreeColorLeafNode</span><span class=p>()</span>

<span class=k>def</span> <span class=nf>leaf_node_update</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
    <span class=k>pass</span>

<span class=k>def</span> <span class=nf>internal_node_init</span><span class=p>():</span>
    <span class=k>return</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>OctreeInternalNode</span><span class=p>()</span>

<span class=k>def</span> <span class=nf>internal_node_update</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
    <span class=k>pass</span>

<span class=k>for</span> <span class=n>point</span> <span class=ow>in</span> <span class=n>points</span><span class=p>:</span>
    <span class=n>octree</span><span class=o>.</span><span class=n>insert_point</span><span class=p>(</span><span class=n>point</span><span class=p>,</span> <span class=n>leaf_node_init</span><span class=p>,</span> <span class=n>leaf_node_update</span><span class=p>,</span> <span class=n>internal_node_init</span><span class=p>,</span> <span class=n>internal_node_update</span><span class=p>)</span>

<span class=c1># 查询 Octree 中的点</span>
<span class=n>query_point</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>])</span>
<span class=n>success</span><span class=p>,</span> <span class=n>node_info</span> <span class=o>=</span> <span class=n>octree</span><span class=o>.</span><span class=n>locate_leaf_node</span><span class=p>(</span><span class=n>query_point</span><span class=p>)</span>
<span class=k>print</span><span class=p>(</span><span class=s2>&#34;查询点:&#34;</span><span class=p>,</span> <span class=n>query_point</span><span class=p>)</span>
<span class=k>print</span><span class=p>(</span><span class=s2>&#34;查询成功:&#34;</span><span class=p>,</span> <span class=n>success</span><span class=p>)</span>
<span class=k>print</span><span class=p>(</span><span class=s2>&#34;节点信息:&#34;</span><span class=p>,</span> <span class=n>node_info</span><span class=p>)</span>

<span class=c1># 可视化 Octree 节点</span>
<span class=k>def</span> <span class=nf>create_pointcloud_from_octree</span><span class=p>(</span><span class=n>octree</span><span class=p>):</span>
    <span class=n>points</span> <span class=o>=</span> <span class=p>[]</span>
    <span class=n>colors</span> <span class=o>=</span> <span class=p>[]</span>
    <span class=k>def</span> <span class=nf>traverse</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>node_info</span><span class=p>):</span>
        <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>OctreeColorLeafNode</span><span class=p>):</span>
            <span class=n>origin</span> <span class=o>=</span> <span class=n>node_info</span><span class=o>.</span><span class=n>origin</span>
            <span class=n>size</span> <span class=o>=</span> <span class=n>node_info</span><span class=o>.</span><span class=n>size</span>
            <span class=n>depth</span> <span class=o>=</span> <span class=n>node_info</span><span class=o>.</span><span class=n>depth</span>
            <span class=c1># 根据深度设置颜色</span>
            <span class=k>if</span> <span class=n>depth</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
                <span class=n>color</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>]</span>  <span class=c1># 红色</span>
            <span class=k>elif</span> <span class=n>depth</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
                <span class=n>color</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>]</span>  <span class=c1># 绿色</span>
            <span class=k>elif</span> <span class=n>depth</span> <span class=o>==</span> <span class=mi>2</span><span class=p>:</span>
                <span class=n>color</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>]</span>  <span class=c1># 蓝色</span>
            <span class=k>elif</span> <span class=n>depth</span> <span class=o>==</span> <span class=mi>3</span><span class=p>:</span>
                <span class=n>color</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>]</span>  <span class=c1># 黄色</span>
            <span class=k>else</span><span class=p>:</span>
                <span class=n>color</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>]</span>  <span class=c1># 青色</span>
            <span class=n>points</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>origin</span> <span class=o>+</span> <span class=n>size</span> <span class=o>/</span> <span class=mi>2</span><span class=p>)</span>
            <span class=n>colors</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>color</span><span class=p>)</span>
        <span class=k>return</span> <span class=bp>False</span>
    <span class=n>octree</span><span class=o>.</span><span class=n>traverse</span><span class=p>(</span><span class=n>traverse</span><span class=p>)</span>
    <span class=n>pointcloud</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>PointCloud</span><span class=p>()</span>
    <span class=n>pointcloud</span><span class=o>.</span><span class=n>points</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>utility</span><span class=o>.</span><span class=n>Vector3dVector</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>points</span><span class=p>))</span>
    <span class=n>pointcloud</span><span class=o>.</span><span class=n>colors</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>utility</span><span class=o>.</span><span class=n>Vector3dVector</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>colors</span><span class=p>))</span>
    <span class=k>return</span> <span class=n>pointcloud</span>

<span class=n>octree_pointcloud</span> <span class=o>=</span> <span class=n>create_pointcloud_from_octree</span><span class=p>(</span><span class=n>octree</span><span class=p>)</span>

<span class=c1># 创建 Octree 的线框表示</span>
<span class=k>def</span> <span class=nf>create_lineset_from_octree</span><span class=p>(</span><span class=n>octree</span><span class=p>):</span>
    <span class=n>lines</span> <span class=o>=</span> <span class=p>[]</span>
    <span class=n>colors</span> <span class=o>=</span> <span class=p>[]</span>
    <span class=n>points</span> <span class=o>=</span> <span class=p>[]</span>
    <span class=k>def</span> <span class=nf>traverse</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>node_info</span><span class=p>):</span>
        <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>OctreeColorLeafNode</span><span class=p>)</span> <span class=ow>or</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>OctreeInternalNode</span><span class=p>):</span>
            <span class=n>origin</span> <span class=o>=</span> <span class=n>node_info</span><span class=o>.</span><span class=n>origin</span>
            <span class=n>size</span> <span class=o>=</span> <span class=n>node_info</span><span class=o>.</span><span class=n>size</span>
            <span class=c1># 添加立方体的 12 条边</span>
            <span class=n>cube_lines</span> <span class=o>=</span> <span class=p>[</span>
                <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>],</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>],</span> <span class=p>[</span><span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>],</span> <span class=p>[</span><span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>],</span>  <span class=c1># 底面</span>
                <span class=p>[</span><span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>],</span> <span class=p>[</span><span class=mi>5</span><span class=p>,</span> <span class=mi>7</span><span class=p>],</span> <span class=p>[</span><span class=mi>7</span><span class=p>,</span> <span class=mi>6</span><span class=p>],</span> <span class=p>[</span><span class=mi>6</span><span class=p>,</span> <span class=mi>4</span><span class=p>],</span>  <span class=c1># 顶面</span>
                <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>4</span><span class=p>],</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>5</span><span class=p>],</span> <span class=p>[</span><span class=mi>2</span><span class=p>,</span> <span class=mi>6</span><span class=p>],</span> <span class=p>[</span><span class=mi>3</span><span class=p>,</span> <span class=mi>7</span><span class=p>]</span>   <span class=c1># 侧面</span>
            <span class=p>]</span>
            <span class=n>cube_points</span> <span class=o>=</span> <span class=p>[</span>
                <span class=n>origin</span><span class=p>,</span>
                <span class=n>origin</span> <span class=o>+</span> <span class=p>[</span><span class=n>size</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>],</span>
                <span class=n>origin</span> <span class=o>+</span> <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=n>size</span><span class=p>,</span> <span class=mi>0</span><span class=p>],</span>
                <span class=n>origin</span> <span class=o>+</span> <span class=p>[</span><span class=n>size</span><span class=p>,</span> <span class=n>size</span><span class=p>,</span> <span class=mi>0</span><span class=p>],</span>
                <span class=n>origin</span> <span class=o>+</span> <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>size</span><span class=p>],</span>
                <span class=n>origin</span> <span class=o>+</span> <span class=p>[</span><span class=n>size</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>size</span><span class=p>],</span>
                <span class=n>origin</span> <span class=o>+</span> <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=n>size</span><span class=p>,</span> <span class=n>size</span><span class=p>],</span>
                <span class=n>origin</span> <span class=o>+</span> <span class=p>[</span><span class=n>size</span><span class=p>,</span> <span class=n>size</span><span class=p>,</span> <span class=n>size</span><span class=p>]</span>
            <span class=p>]</span>
            <span class=n>base_index</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>points</span><span class=p>)</span>
            <span class=n>points</span><span class=o>.</span><span class=n>extend</span><span class=p>(</span><span class=n>cube_points</span><span class=p>)</span>
            <span class=n>lines</span><span class=o>.</span><span class=n>extend</span><span class=p>([[</span><span class=n>base_index</span> <span class=o>+</span> <span class=n>start</span><span class=p>,</span> <span class=n>base_index</span> <span class=o>+</span> <span class=n>end</span><span class=p>]</span> <span class=k>for</span> <span class=n>start</span><span class=p>,</span> <span class=n>end</span> <span class=ow>in</span> <span class=n>cube_lines</span><span class=p>])</span>
            <span class=n>colors</span><span class=o>.</span><span class=n>extend</span><span class=p>([[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>cube_lines</span><span class=p>))])</span>  <span class=c1># 黑色</span>
        <span class=k>return</span> <span class=bp>False</span>
    <span class=n>octree</span><span class=o>.</span><span class=n>traverse</span><span class=p>(</span><span class=n>traverse</span><span class=p>)</span>
    <span class=n>lineset</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>LineSet</span><span class=p>()</span>
    <span class=n>lineset</span><span class=o>.</span><span class=n>points</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>utility</span><span class=o>.</span><span class=n>Vector3dVector</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>points</span><span class=p>))</span>
    <span class=n>lineset</span><span class=o>.</span><span class=n>lines</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>utility</span><span class=o>.</span><span class=n>Vector2iVector</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>lines</span><span class=p>))</span>
    <span class=n>lineset</span><span class=o>.</span><span class=n>colors</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>utility</span><span class=o>.</span><span class=n>Vector3dVector</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>colors</span><span class=p>))</span>
    <span class=k>return</span> <span class=n>lineset</span>

<span class=n>octree_lineset</span> <span class=o>=</span> <span class=n>create_lineset_from_octree</span><span class=p>(</span><span class=n>octree</span><span class=p>)</span>

<span class=c1># 创建找到的立方体</span>
<span class=k>if</span> <span class=n>success</span><span class=p>:</span>
    <span class=n>origin</span> <span class=o>=</span> <span class=n>node_info</span><span class=o>.</span><span class=n>origin</span>
    <span class=n>size</span> <span class=o>=</span> <span class=n>node_info</span><span class=o>.</span><span class=n>size</span>
    <span class=n>cube</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>TriangleMesh</span><span class=o>.</span><span class=n>create_box</span><span class=p>(</span><span class=n>width</span><span class=o>=</span><span class=n>size</span><span class=p>,</span> <span class=n>height</span><span class=o>=</span><span class=n>size</span><span class=p>,</span> <span class=n>depth</span><span class=o>=</span><span class=n>size</span><span class=p>)</span>
    <span class=n>cube</span><span class=o>.</span><span class=n>translate</span><span class=p>(</span><span class=n>origin</span><span class=p>)</span>
    <span class=n>cube</span><span class=o>.</span><span class=n>paint_uniform_color</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>])</span>  <span class=c1># 红色</span>

<span class=c1># 使用默认的绘制函数来显示点云和 Octree</span>
<span class=n>geometries</span> <span class=o>=</span> <span class=p>[</span><span class=n>octree_pointcloud</span><span class=p>,</span> <span class=n>octree_lineset</span><span class=p>]</span>
<span class=k>if</span> <span class=n>success</span><span class=p>:</span>
    <span class=n>geometries</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>cube</span><span class=p>)</span>
<span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>(</span><span class=n>geometries</span><span class=p>)</span>

</code></pre></div><p><figure><img src=octree_1.png alt=octree_1 loading=lazy></figure>这段代码展示了如何使用 Open3D 库创建一个 Octree，插入点，查询节点，并可视化 Octree 结构及其节点。</p><ol><li><p><strong>创建随机点云</strong>：</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>pcd</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>PointCloud</span><span class=p>()</span>
<span class=n>pcd</span><span class=o>.</span><span class=n>points</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>utility</span><span class=o>.</span><span class=n>Vector3dVector</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>rand</span><span class=p>(</span><span class=mi>5000</span><span class=p>,</span> <span class=mi>3</span><span class=p>))</span>
</code></pre></div></li><li><p><strong>构建 Octree</strong>：</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>octree</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>Octree</span><span class=p>(</span><span class=n>max_depth</span><span class=o>=</span><span class=mi>4</span><span class=p>)</span>
<span class=n>octree</span><span class=o>.</span><span class=n>convert_from_point_cloud</span><span class=p>(</span><span class=n>pcd</span><span class=p>,</span> <span class=n>size_expand</span><span class=o>=</span><span class=mf>0.01</span><span class=p>)</span>
</code></pre></div></li><li><p><strong>插入多个点</strong>：</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>points</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>rand</span><span class=p>(</span><span class=mi>100</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
<span class=k>for</span> <span class=n>point</span> <span class=ow>in</span> <span class=n>points</span><span class=p>:</span>
    <span class=n>octree</span><span class=o>.</span><span class=n>insert_point</span><span class=p>(</span><span class=n>point</span><span class=p>,</span> <span class=n>leaf_node_init</span><span class=p>,</span> <span class=n>leaf_node_update</span><span class=p>,</span> <span class=n>internal_node_init</span><span class=p>,</span> <span class=n>internal_node_update</span><span class=p>)</span>
</code></pre></div></li><li><p><strong>查询 Octree 中的点</strong>：</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>query_point</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>])</span>
<span class=n>success</span><span class=p>,</span> <span class=n>node_info</span> <span class=o>=</span> <span class=n>octree</span><span class=o>.</span><span class=n>locate_leaf_node</span><span class=p>(</span><span class=n>query_point</span><span class=p>)</span>
</code></pre></div></li><li><p><strong>可视化 Octree 和查询结果</strong>：</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>octree_pointcloud</span> <span class=o>=</span> <span class=n>create_pointcloud_from_octree</span><span class=p>(</span><span class=n>octree</span><span class=p>)</span>
<span class=n>octree_lineset</span> <span class=o>=</span> <span class=n>create_lineset_from_octree</span><span class=p>(</span><span class=n>octree</span><span class=p>)</span>
<span class=k>if</span> <span class=n>success</span><span class=p>:</span>
    <span class=n>cube</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>TriangleMesh</span><span class=o>.</span><span class=n>create_box</span><span class=p>(</span><span class=n>width</span><span class=o>=</span><span class=n>node_info</span><span class=o>.</span><span class=n>size</span><span class=p>,</span> <span class=n>height</span><span class=o>=</span><span class=n>node_info</span><span class=o>.</span><span class=n>size</span><span class=p>,</span> <span class=n>depth</span><span class=o>=</span><span class=n>node_info</span><span class=o>.</span><span class=n>size</span><span class=p>)</span>
    <span class=n>cube</span><span class=o>.</span><span class=n>translate</span><span class=p>(</span><span class=n>node_info</span><span class=o>.</span><span class=n>origin</span><span class=p>)</span>
    <span class=n>cube</span><span class=o>.</span><span class=n>paint_uniform_color</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>])</span>
<span class=n>geometries</span> <span class=o>=</span> <span class=p>[</span><span class=n>octree_pointcloud</span><span class=p>,</span> <span class=n>octree_lineset</span><span class=p>,</span> <span class=n>cube</span><span class=p>]</span> <span class=k>if</span> <span class=n>success</span> <span class=k>else</span> <span class=p>[</span><span class=n>octree_pointcloud</span><span class=p>,</span> <span class=n>octree_lineset</span><span class=p>]</span>
<span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>(</span><span class=n>geometries</span><span class=p>)</span>
</code></pre></div></li></ol><h3 id=647-点云分割>6.4.7 点云分割<a hidden class=anchor aria-hidden=true href=#647-点云分割>#</a></h3><p>在 Open3D 中使用 Octree 进行点云分割可以通过以下步骤实现：</p><ul><li><p>创建点云并构建 Octree：</p><ul><li>创建一个点云对象并填充点数据。</li><li>使用点云数据构建 Octree。</li></ul></li><li><p>遍历 Octree 并分割点云：</p><ul><li>遍历 Octree 的叶节点。</li><li>根据叶节点的信息将点云分割成不同的部分。</li></ul></li></ul><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>open3d</span> <span class=kn>as</span> <span class=nn>o3d</span>
<span class=kn>import</span> <span class=nn>numpy</span> <span class=kn>as</span> <span class=nn>np</span>

<span class=c1># 创建多个点云簇</span>
<span class=k>def</span> <span class=nf>create_clustered_point_cloud</span><span class=p>(</span><span class=n>num_clusters</span><span class=o>=</span><span class=mi>5</span><span class=p>,</span> <span class=n>points_per_cluster</span><span class=o>=</span><span class=mi>2000</span><span class=p>,</span> <span class=n>cluster_radius</span><span class=o>=</span><span class=mf>0.05</span><span class=p>):</span>
    <span class=n>points</span> <span class=o>=</span> <span class=p>[]</span>
    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>num_clusters</span><span class=p>):</span>
        <span class=n>cluster_center</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>rand</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
        <span class=n>cluster_points</span> <span class=o>=</span> <span class=n>cluster_center</span> <span class=o>+</span> <span class=n>cluster_radius</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>randn</span><span class=p>(</span><span class=n>points_per_cluster</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
        <span class=n>points</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>cluster_points</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>np</span><span class=o>.</span><span class=n>vstack</span><span class=p>(</span><span class=n>points</span><span class=p>)</span>

<span class=c1># 生成点云</span>
<span class=n>pcd</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>PointCloud</span><span class=p>()</span>
<span class=n>pcd</span><span class=o>.</span><span class=n>points</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>utility</span><span class=o>.</span><span class=n>Vector3dVector</span><span class=p>(</span><span class=n>create_clustered_point_cloud</span><span class=p>())</span>

<span class=c1># 构建 Octree</span>
<span class=n>max_depth</span> <span class=o>=</span> <span class=mi>4</span>  <span class=c1># 调整 Octree 的深度</span>
<span class=n>octree</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>Octree</span><span class=p>(</span><span class=n>max_depth</span><span class=p>)</span>
<span class=n>octree</span><span class=o>.</span><span class=n>convert_from_point_cloud</span><span class=p>(</span><span class=n>pcd</span><span class=p>,</span> <span class=n>size_expand</span><span class=o>=</span><span class=mf>0.01</span><span class=p>)</span>

<span class=c1># 分割点云并为每个部分赋予不同的颜色</span>
<span class=k>def</span> <span class=nf>segment_point_cloud</span><span class=p>(</span><span class=n>octree</span><span class=p>):</span>
    <span class=n>segments</span> <span class=o>=</span> <span class=p>[]</span>
    <span class=n>colors</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>rand</span><span class=p>(</span><span class=mi>100</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>  <span class=c1># 生成随机颜色</span>
    <span class=n>color_index</span> <span class=o>=</span> <span class=mi>0</span>

    <span class=k>def</span> <span class=nf>traverse</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>node_info</span><span class=p>):</span>
        <span class=n>nonlocal</span> <span class=n>color_index</span>
        <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>OctreeLeafNode</span><span class=p>):</span>
            <span class=c1># 获取叶节点中的点</span>
            <span class=n>segment</span> <span class=o>=</span> <span class=n>pcd</span><span class=o>.</span><span class=n>select_by_index</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>indices</span><span class=p>)</span>
            <span class=n>segment</span><span class=o>.</span><span class=n>paint_uniform_color</span><span class=p>(</span><span class=n>colors</span><span class=p>[</span><span class=n>color_index</span> <span class=o>%</span> <span class=nb>len</span><span class=p>(</span><span class=n>colors</span><span class=p>)])</span>
            <span class=n>segments</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>segment</span><span class=p>)</span>
            <span class=n>color_index</span> <span class=o>+=</span> <span class=mi>1</span>
        <span class=k>return</span> <span class=bp>False</span>

    <span class=n>octree</span><span class=o>.</span><span class=n>traverse</span><span class=p>(</span><span class=n>traverse</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>segments</span>

<span class=c1># 获取分割后的点云部分</span>
<span class=n>segments</span> <span class=o>=</span> <span class=n>segment_point_cloud</span><span class=p>(</span><span class=n>octree</span><span class=p>)</span>

<span class=c1># 检查是否有分割后的点云部分</span>
<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>segments</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
    <span class=k>print</span><span class=p>(</span><span class=s2>&#34;没有分割后的点云部分，请检查 Octree 构建和遍历逻辑。&#34;</span><span class=p>)</span>
<span class=k>else</span><span class=p>:</span>
    <span class=c1># 可视化分割后的点云</span>
    <span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>(</span><span class=n>segments</span><span class=p>)</span>
</code></pre></div><p><figure><img src=segment.png alt=segment loading=lazy></figure></p><p>6.4.8 点云过滤
在 Open3D 中使用 Octree 进行点云滤波可以通过以下步骤实现：</p><ul><li>创建点云并构建 Octree。</li><li>定义滤波条件。</li><li>遍历 Octree 并应用滤波条件。</li><li>生成滤波后的点云。</li></ul><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>open3d</span> <span class=kn>as</span> <span class=nn>o3d</span>
<span class=kn>import</span> <span class=nn>numpy</span> <span class=kn>as</span> <span class=nn>np</span>

<span class=c1># 创建一个随机点云</span>
<span class=n>pcd</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>PointCloud</span><span class=p>()</span>
<span class=n>pcd</span><span class=o>.</span><span class=n>points</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>utility</span><span class=o>.</span><span class=n>Vector3dVector</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>rand</span><span class=p>(</span><span class=mi>10000</span><span class=p>,</span> <span class=mi>3</span><span class=p>))</span>

<span class=c1># 构建 Octree</span>
<span class=n>max_depth</span> <span class=o>=</span> <span class=mi>4</span>  <span class=c1># 调整 Octree 的深度</span>
<span class=n>octree</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>Octree</span><span class=p>(</span><span class=n>max_depth</span><span class=p>)</span>
<span class=n>octree</span><span class=o>.</span><span class=n>convert_from_point_cloud</span><span class=p>(</span><span class=n>pcd</span><span class=p>,</span> <span class=n>size_expand</span><span class=o>=</span><span class=mf>0.01</span><span class=p>)</span>

<span class=c1># 定义体素滤波函数</span>
<span class=k>def</span> <span class=nf>voxel_filter</span><span class=p>(</span><span class=n>octree</span><span class=p>,</span> <span class=n>voxel_size</span><span class=p>):</span>
    <span class=n>filtered_points</span> <span class=o>=</span> <span class=p>[]</span>

    <span class=k>def</span> <span class=nf>traverse</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>node_info</span><span class=p>):</span>
        <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>OctreeLeafNode</span><span class=p>):</span>
            <span class=c1># 计算叶节点的中心点</span>
            <span class=n>voxel_center</span> <span class=o>=</span> <span class=n>node_info</span><span class=o>.</span><span class=n>origin</span> <span class=o>+</span> <span class=n>node_info</span><span class=o>.</span><span class=n>size</span> <span class=o>/</span> <span class=mi>2</span>
            <span class=n>filtered_points</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>voxel_center</span><span class=p>)</span>
        <span class=k>return</span> <span class=bp>False</span>

    <span class=n>octree</span><span class=o>.</span><span class=n>traverse</span><span class=p>(</span><span class=n>traverse</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>filtered_points</span>

<span class=c1># 设置体素大小</span>
<span class=n>voxel_size</span> <span class=o>=</span> <span class=mf>0.05</span>

<span class=c1># 获取滤波后的点云</span>
<span class=n>filtered_points</span> <span class=o>=</span> <span class=n>voxel_filter</span><span class=p>(</span><span class=n>octree</span><span class=p>,</span> <span class=n>voxel_size</span><span class=p>)</span>
<span class=n>filtered_pcd</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>PointCloud</span><span class=p>()</span>
<span class=n>filtered_pcd</span><span class=o>.</span><span class=n>points</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>utility</span><span class=o>.</span><span class=n>Vector3dVector</span><span class=p>(</span><span class=n>filtered_points</span><span class=p>)</span>

<span class=c1># 可视化原始点云和滤波后的点云</span>
<span class=k>print</span><span class=p>(</span><span class=s2>&#34;原始点云点数:&#34;</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>pcd</span><span class=o>.</span><span class=n>points</span><span class=p>))</span>
<span class=k>print</span><span class=p>(</span><span class=s2>&#34;滤波后点云点数:&#34;</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>filtered_pcd</span><span class=o>.</span><span class=n>points</span><span class=p>))</span>
<span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>([</span><span class=n>pcd</span><span class=p>],</span> <span class=n>window_name</span><span class=o>=</span><span class=s2>&#34;原始点云&#34;</span><span class=p>)</span>
<span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>([</span><span class=n>filtered_pcd</span><span class=p>],</span> <span class=n>window_name</span><span class=o>=</span><span class=s2>&#34;滤波后点云&#34;</span><span class=p>)</span>
</code></pre></div><table><thead><tr><th>过滤前</th><th>过滤后</th></tr></thead><tbody><tr><td><figure><img src=filtered_pcd.png alt=filtered_pcd loading=lazy></figure></td><td><figure><img src=filtered_pcd_1.png alt=filtered_pcd_1 loading=lazy></figure></td></tr></tbody></table><h1 id=7-点云过滤>7. 点云过滤<a hidden class=anchor aria-hidden=true href=#7-点云过滤>#</a></h1><p>Open3D 提供了以下几种常用的点云滤波方法：</p><ol><li><p><strong>统计滤波 (Statistical Outlier Removal)</strong>：</p><ul><li>方法：<code>remove_statistical_outlier</code></li><li>参数：<ul><li><code>nb_neighbors</code>：用于计算平均距离的邻居点数。</li><li><code>std_ratio</code>：距离的标准差乘数。</li></ul></li></ul></li><li><p><strong>半径滤波 (Radius Outlier Removal)</strong>：</p><ul><li>方法：<code>remove_radius_outlier</code></li><li>参数：<ul><li><code>nb_points</code>：在指定半径内的最小点数。</li><li><code>radius</code>：搜索半径。</li></ul></li></ul></li><li><p><strong>体素下采样 (Voxel Downsampling)</strong>：</p><ul><li>方法：<code>voxel_down_sample</code></li><li>参数：<ul><li><code>voxel_size</code>：体素的大小。</li></ul></li></ul></li><li><p><strong>Uniform Downsampling</strong>：</p><ul><li>方法：<code>uniform_down_sample</code></li><li>参数：<ul><li><code>every_k_points</code>：每隔多少个点采样一个点。</li></ul></li></ul></li></ol><p>以下是这些方法的示例代码：</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>open3d</span> <span class=kn>as</span> <span class=nn>o3d</span>
<span class=kn>import</span> <span class=nn>numpy</span> <span class=kn>as</span> <span class=nn>np</span>

<span class=c1># 创建一个随机点云</span>
<span class=n>pcd</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>PointCloud</span><span class=p>()</span>
<span class=n>pcd</span><span class=o>.</span><span class=n>points</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>utility</span><span class=o>.</span><span class=n>Vector3dVector</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>rand</span><span class=p>(</span><span class=mi>10000</span><span class=p>,</span> <span class=mi>3</span><span class=p>))</span>

<span class=c1># 统计滤波</span>
<span class=n>pcd_statistical</span><span class=p>,</span> <span class=n>ind_statistical</span> <span class=o>=</span> <span class=n>pcd</span><span class=o>.</span><span class=n>remove_statistical_outlier</span><span class=p>(</span><span class=n>nb_neighbors</span><span class=o>=</span><span class=mi>20</span><span class=p>,</span> <span class=n>std_ratio</span><span class=o>=</span><span class=mf>1.0</span><span class=p>)</span>
<span class=n>filtered_pcd_statistical</span> <span class=o>=</span> <span class=n>pcd</span><span class=o>.</span><span class=n>select_by_index</span><span class=p>(</span><span class=n>ind_statistical</span><span class=p>)</span>

<span class=c1># 半径滤波</span>
<span class=n>pcd_radius</span><span class=p>,</span> <span class=n>ind_radius</span> <span class=o>=</span> <span class=n>pcd</span><span class=o>.</span><span class=n>remove_radius_outlier</span><span class=p>(</span><span class=n>nb_points</span><span class=o>=</span><span class=mi>10</span><span class=p>,</span> <span class=n>radius</span><span class=o>=</span><span class=mf>0.1</span><span class=p>)</span>
<span class=n>filtered_pcd_radius</span> <span class=o>=</span> <span class=n>pcd</span><span class=o>.</span><span class=n>select_by_index</span><span class=p>(</span><span class=n>ind_radius</span><span class=p>)</span>

<span class=c1># 体素下采样</span>
<span class=n>voxel_size</span> <span class=o>=</span> <span class=mf>0.05</span>
<span class=n>downsampled_pcd_voxel</span> <span class=o>=</span> <span class=n>pcd</span><span class=o>.</span><span class=n>voxel_down_sample</span><span class=p>(</span><span class=n>voxel_size</span><span class=p>)</span>

<span class=c1># Uniform 下采样</span>
<span class=n>every_k_points</span> <span class=o>=</span> <span class=mi>10</span>
<span class=n>downsampled_pcd_uniform</span> <span class=o>=</span> <span class=n>pcd</span><span class=o>.</span><span class=n>uniform_down_sample</span><span class=p>(</span><span class=n>every_k_points</span><span class=p>)</span>

<span class=c1># 可视化原始点云和过滤后的点云</span>
<span class=k>print</span><span class=p>(</span><span class=s2>&#34;原始点云点数:&#34;</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>pcd</span><span class=o>.</span><span class=n>points</span><span class=p>))</span>
<span class=k>print</span><span class=p>(</span><span class=s2>&#34;统计滤波后的点云点数:&#34;</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>filtered_pcd_statistical</span><span class=o>.</span><span class=n>points</span><span class=p>))</span>
<span class=k>print</span><span class=p>(</span><span class=s2>&#34;半径滤波后的点云点数:&#34;</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>filtered_pcd_radius</span><span class=o>.</span><span class=n>points</span><span class=p>))</span>
<span class=k>print</span><span class=p>(</span><span class=s2>&#34;体素下采样后的点云点数:&#34;</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>downsampled_pcd_voxel</span><span class=o>.</span><span class=n>points</span><span class=p>))</span>
<span class=k>print</span><span class=p>(</span><span class=s2>&#34;Uniform下采样后的点云点数:&#34;</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>downsampled_pcd_uniform</span><span class=o>.</span><span class=n>points</span><span class=p>))</span>

<span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>([</span><span class=n>pcd</span><span class=p>],</span> <span class=n>window_name</span><span class=o>=</span><span class=s2>&#34;原始点云&#34;</span><span class=p>)</span>
<span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>([</span><span class=n>filtered_pcd_statistical</span><span class=p>],</span> <span class=n>window_name</span><span class=o>=</span><span class=s2>&#34;统计滤波后的点云&#34;</span><span class=p>)</span>
<span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>([</span><span class=n>filtered_pcd_radius</span><span class=p>],</span> <span class=n>window_name</span><span class=o>=</span><span class=s2>&#34;半径滤波后的点云&#34;</span><span class=p>)</span>
<span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>([</span><span class=n>downsampled_pcd_voxel</span><span class=p>],</span> <span class=n>window_name</span><span class=o>=</span><span class=s2>&#34;体素下采样后的点云&#34;</span><span class=p>)</span>
<span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>([</span><span class=n>downsampled_pcd_uniform</span><span class=p>],</span> <span class=n>window_name</span><span class=o>=</span><span class=s2>&#34;Uniform下采样后的点云&#34;</span><span class=p>)</span>
</code></pre></div><p><figure><img src=outlier_1.png alt=outlier_1 loading=lazy></figure><figure><img src=outlier_2.png alt=outlier_2 loading=lazy></figure><figure><img src=outlier_3.png alt=outlier_3 loading=lazy></figure><figure><img src=outlier_4.png alt=outlier_4 loading=lazy></figure><figure><img src=outlier_5.png alt=outlier_5 loading=lazy></figure></p><ul><li><strong>代码说明</strong>：</li></ul><ol><li><strong>统计滤波</strong>：使用 <code>remove_statistical_outlier</code> 方法去除离群点。该方法通过计算每个点的邻居点的平均距离，并将距离超过标准差乘数的点视为离群点。参数 <code>nb_neighbors</code> 指定用于计算平均距离的邻居点数，<code>std_ratio</code> 指定距离的标准差乘数。</li><li><strong>半径滤波</strong>：使用 <code>remove_radius_outlier</code> 方法去除孤立点。该方法通过检查每个点在指定半径内的邻居点数，并将邻居点数少于指定值的点视为孤立点。参数 <code>nb_points</code> 指定在指定半径内的最小点数，<code>radius</code> 指定搜索半径。</li><li><strong>体素下采样</strong>：使用 <code>voxel_down_sample</code> 方法通过体素网格下采样点云。该方法将点云划分为体素网格，并用每个体素内的点的重心来代表该体素。参数 <code>voxel_size</code> 指定体素的大小。</li><li><strong>Uniform 下采样</strong>：使用 <code>uniform_down_sample</code> 方法均匀下采样点云。该方法通过按固定间隔选择点来下采样点云。参数 <code>every_k_points</code> 指定每隔多少个点采样一个点。</li></ol><p>这些方法可以帮助你在不同的场景下对点云进行预处理和优化，以提高点云处理的效率和效果。</p><h1 id=8-点云转换>8. 点云转换<a hidden class=anchor aria-hidden=true href=#8-点云转换>#</a></h1><h2 id=81-transform应用变换矩阵到点云>8.1 <strong>transform</strong>：应用变换矩阵到点云<a hidden class=anchor aria-hidden=true href=#81-transform应用变换矩阵到点云>#</a></h2><p><code>transform</code> 方法用于将一个 4x4 的变换矩阵应用到点云上。该矩阵可以包含平移、旋转和缩放。</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>open3d</span> <span class=kn>as</span> <span class=nn>o3d</span>
<span class=kn>import</span> <span class=nn>numpy</span> <span class=kn>as</span> <span class=nn>np</span>

<span class=c1># 创建一个随机点云</span>
<span class=n>pcd</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>PointCloud</span><span class=p>()</span>
<span class=n>pcd</span><span class=o>.</span><span class=n>points</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>utility</span><span class=o>.</span><span class=n>Vector3dVector</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>rand</span><span class=p>(</span><span class=mi>1000</span><span class=p>,</span> <span class=mi>3</span><span class=p>))</span>

<span class=c1># 定义一个变换矩阵</span>
<span class=n>transformation_matrix</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>],</span>
                                  <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>],</span>
                                  <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>],</span>
                                  <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>]])</span>

<span class=c1># 应用变换矩阵到点云</span>
<span class=n>pcd</span><span class=o>.</span><span class=n>transform</span><span class=p>(</span><span class=n>transformation_matrix</span><span class=p>)</span>

<span class=c1># 可视化变换后的点云</span>
<span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>([</span><span class=n>pcd</span><span class=p>],</span> <span class=n>window_name</span><span class=o>=</span><span class=s2>&#34;Transformed Point Cloud&#34;</span><span class=p>)</span>
</code></pre></div><h2 id=82-translate平移点云>8.2 <strong>translate</strong>：平移点云<a hidden class=anchor aria-hidden=true href=#82-translate平移点云>#</a></h2><p><code>translate</code> 方法用于将点云沿指定的方向平移。</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=c1># 平移向量</span>
<span class=n>translation_vector</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>])</span>

<span class=c1># 平移点云</span>
<span class=n>pcd</span><span class=o>.</span><span class=n>translate</span><span class=p>(</span><span class=n>translation_vector</span><span class=p>)</span>

<span class=c1># 可视化平移后的点云</span>
<span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>([</span><span class=n>pcd</span><span class=p>],</span> <span class=n>window_name</span><span class=o>=</span><span class=s2>&#34;Translated Point Cloud&#34;</span><span class=p>)</span>
</code></pre></div><h2 id=83-rotate旋转点云>8.3 <strong>rotate</strong>：旋转点云<a hidden class=anchor aria-hidden=true href=#83-rotate旋转点云>#</a></h2><p><code>rotate</code> 方法用于将点云绕指定的轴旋转。旋转矩阵可以通过欧拉角或四元数生成。</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=c1># 定义一个旋转矩阵（绕 Z 轴旋转 45 度）</span>
<span class=n>rotation_matrix</span> <span class=o>=</span> <span class=n>pcd</span><span class=o>.</span><span class=n>get_rotation_matrix_from_xyz</span><span class=p>((</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>pi</span> <span class=o>/</span> <span class=mi>4</span><span class=p>))</span>

<span class=c1># 旋转点云</span>
<span class=n>pcd</span><span class=o>.</span><span class=n>rotate</span><span class=p>(</span><span class=n>rotation_matrix</span><span class=p>,</span> <span class=n>center</span><span class=o>=</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span>

<span class=c1># 可视化旋转后的点云</span>
<span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>([</span><span class=n>pcd</span><span class=p>],</span> <span class=n>window_name</span><span class=o>=</span><span class=s2>&#34;Rotated Point Cloud&#34;</span><span class=p>)</span>
</code></pre></div><h2 id=84-scale缩放点云>8.4 <strong>scale</strong>：缩放点云<a hidden class=anchor aria-hidden=true href=#84-scale缩放点云>#</a></h2><p><code>scale</code> 方法用于将点云按指定的比例缩放。</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=c1># 缩放比例</span>
<span class=n>scale_factor</span> <span class=o>=</span> <span class=mf>2.0</span>

<span class=c1># 缩放点云</span>
<span class=n>pcd</span><span class=o>.</span><span class=n>scale</span><span class=p>(</span><span class=n>scale_factor</span><span class=p>,</span> <span class=n>center</span><span class=o>=</span><span class=n>pcd</span><span class=o>.</span><span class=n>get_center</span><span class=p>())</span>

<span class=c1># 可视化缩放后的点云</span>
<span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>([</span><span class=n>pcd</span><span class=p>],</span> <span class=n>window_name</span><span class=o>=</span><span class=s2>&#34;Scaled Point Cloud&#34;</span><span class=p>)</span>
</code></pre></div><h1 id=9-点云法线估计>9. 点云法线估计<a hidden class=anchor aria-hidden=true href=#9-点云法线估计>#</a></h1><h2 id=91-estimate_normals估计点云法线>9.1 <strong>estimate_normals</strong>：估计点云法线<a hidden class=anchor aria-hidden=true href=#91-estimate_normals估计点云法线>#</a></h2><p><code>estimate_normals</code> 方法用于估计点云的法线。该方法通过计算每个点的邻域点的协方差矩阵，并求解其特征向量来确定法线方向。</p><ul><li><strong>参数说明</strong>：</li><li><code>search_param</code>：搜索参数，定义了用于法线估计的邻域搜索方法和半径。<ul><li><code>search_param=o3d.geometry.KDTreeSearchParamKNN(knn)</code>：使用 K 近邻搜索，<code>knn</code> 为邻居点的数量。</li><li><code>search_param=o3d.geometry.KDTreeSearchParamRadius(radius)</code>：使用半径搜索，<code>radius</code> 为搜索半径。</li></ul></li></ul><h2 id=92-orient_normals_consistent_tangent_plane使法线方向一致>9.2 <strong>orient_normals_consistent_tangent_plane</strong>：使法线方向一致<a hidden class=anchor aria-hidden=true href=#92-orient_normals_consistent_tangent_plane使法线方向一致>#</a></h2><p><code>orient_normals_consistent_tangent_plane</code> 方法用于使点云的法线方向一致。该方法通过构建一致的切平面来调整法线方向。</p><ul><li><strong>参数说明</strong>：</li><li><code>k</code>：用于一致性调整的邻居点数量。</li></ul><h2 id=93-详细案例>9.3 详细案例<a hidden class=anchor aria-hidden=true href=#93-详细案例>#</a></h2><p>以下是一个完整的案例，展示了如何读取点云、估计法线并使法线方向一致：</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>open3d</span> <span class=kn>as</span> <span class=nn>o3d</span>
<span class=kn>import</span> <span class=nn>numpy</span> <span class=kn>as</span> <span class=nn>np</span>

<span class=c1># 生成点云数据</span>
<span class=k>def</span> <span class=nf>generate_point_cloud</span><span class=p>():</span>
    <span class=c1># 生成一个简单的平面点云</span>
    <span class=n>mesh</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>TriangleMesh</span><span class=o>.</span><span class=n>create_sphere</span><span class=p>(</span><span class=n>radius</span><span class=o>=</span><span class=mf>1.0</span><span class=p>)</span>
    <span class=n>pcd</span> <span class=o>=</span> <span class=n>mesh</span><span class=o>.</span><span class=n>sample_points_poisson_disk</span><span class=p>(</span><span class=n>number_of_points</span><span class=o>=</span><span class=mi>500</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>pcd</span>

<span class=c1># 生成点云</span>
<span class=n>pcd</span> <span class=o>=</span> <span class=n>generate_point_cloud</span><span class=p>()</span>

<span class=c1># 打印点云信息</span>
<span class=k>print</span><span class=p>(</span><span class=s2>&#34;Point cloud before normal estimation:&#34;</span><span class=p>)</span>
<span class=k>print</span><span class=p>(</span><span class=n>pcd</span><span class=p>)</span>

<span class=c1># 估计法线</span>
<span class=k>print</span><span class=p>(</span><span class=s2>&#34;Estimating normals...&#34;</span><span class=p>)</span>
<span class=n>pcd</span><span class=o>.</span><span class=n>estimate_normals</span><span class=p>(</span><span class=n>search_param</span><span class=o>=</span><span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>KDTreeSearchParamKNN</span><span class=p>(</span><span class=n>knn</span><span class=o>=</span><span class=mi>30</span><span class=p>))</span>

<span class=c1># 打印估计法线后的点云信息</span>
<span class=k>print</span><span class=p>(</span><span class=s2>&#34;Point cloud after normal estimation:&#34;</span><span class=p>)</span>
<span class=k>print</span><span class=p>(</span><span class=n>pcd</span><span class=p>)</span>

<span class=c1># 可视化带法线的点云</span>
<span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>([</span><span class=n>pcd</span><span class=p>],</span> <span class=n>point_show_normal</span><span class=o>=</span><span class=bp>True</span><span class=p>,</span> <span class=n>window_name</span><span class=o>=</span><span class=s2>&#34;Point Cloud with Normals&#34;</span><span class=p>)</span>

<span class=c1># 使法线方向一致</span>
<span class=k>print</span><span class=p>(</span><span class=s2>&#34;Orienting normals consistently...&#34;</span><span class=p>)</span>
<span class=n>pcd</span><span class=o>.</span><span class=n>orient_normals_consistent_tangent_plane</span><span class=p>(</span><span class=n>k</span><span class=o>=</span><span class=mi>30</span><span class=p>)</span>

<span class=c1># 打印调整法线方向后的点云信息</span>
<span class=k>print</span><span class=p>(</span><span class=s2>&#34;Point cloud after orienting normals:&#34;</span><span class=p>)</span>
<span class=k>print</span><span class=p>(</span><span class=n>pcd</span><span class=p>)</span>

<span class=c1># 可视化带一致法线的点云</span>
<span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>([</span><span class=n>pcd</span><span class=p>],</span> <span class=n>point_show_normal</span><span class=o>=</span><span class=bp>True</span><span class=p>,</span> <span class=n>window_name</span><span class=o>=</span><span class=s2>&#34;Point Cloud with Oriented Normals&#34;</span><span class=p>)</span>
</code></pre></div><table><thead><tr><th>法向生成</th><th>法向统一</th></tr></thead><tbody><tr><td><figure><img src=normal_1.png alt=normal_1 loading=lazy></figure></td><td><figure><img src=normal_2.png alt=normal_2 loading=lazy></figure></td></tr></tbody></table><p>通过 <code>estimate_normals</code> 和 <code>orient_normals_consistent_tangent_plane</code> 方法，你可以估计点云的法线并使其方向一致。这对于后续的点云处理和分析（如表面重建、配准等）非常重要。</p><h1 id=10-点云配准>10. 点云配准<a hidden class=anchor aria-hidden=true href=#10-点云配准>#</a></h1><p>Open3D 提供了多种点云配准方法，主要包括以下几种：</p><ol><li><p><strong>ICP (Iterative Closest Point) 配准</strong>：这是最常用的点云配准方法之一，通过迭代地最小化两组点云之间的距离来实现配准。</p></li><li><p><strong>Colored ICP 配准</strong>：这是对传统 ICP 的改进，除了几何距离外，还考虑了颜色信息来进行配准。</p></li><li><p><strong>Global Registration (全局配准)</strong>：用于初始配准，通常在没有初始对齐的情况下使用。包括 RANSAC-based 和 Fast Global Registration (FGR) 方法。</p></li><li><p><strong>Multiway Registration (多路配准)</strong>：用于将多个点云配准到一个共同的参考框架中。</p></li></ol><p>下面是每种方法的说明和案例：</p><h2 id=101-icp-配准>10.1 ICP 配准<a hidden class=anchor aria-hidden=true href=#101-icp-配准>#</a></h2><p><strong>说明</strong>：通过迭代地最小化两组点云之间的距离来实现配准。</p><p><strong>案例</strong>：</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>open3d</span> <span class=kn>as</span> <span class=nn>o3d</span>
<span class=kn>import</span> <span class=nn>numpy</span> <span class=kn>as</span> <span class=nn>np</span>

<span class=k>def</span> <span class=nf>create_colored_point_cloud</span><span class=p>(</span><span class=n>color</span><span class=p>):</span>
    <span class=s2>&#34;&#34;&#34;创建并上色的球体点云&#34;&#34;&#34;</span>
    <span class=n>pcd</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>TriangleMesh</span><span class=o>.</span><span class=n>create_sphere</span><span class=p>(</span><span class=n>radius</span><span class=o>=</span><span class=mf>1.0</span><span class=p>)</span><span class=o>.</span><span class=n>sample_points_uniformly</span><span class=p>(</span><span class=n>number_of_points</span><span class=o>=</span><span class=mi>1000</span><span class=p>)</span>
    <span class=n>pcd</span><span class=o>.</span><span class=n>paint_uniform_color</span><span class=p>(</span><span class=n>color</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>pcd</span>

<span class=k>def</span> <span class=nf>visualize_point_clouds</span><span class=p>(</span><span class=n>pcd1</span><span class=p>,</span> <span class=n>pcd2</span><span class=p>,</span> <span class=n>window_name</span><span class=p>):</span>
    <span class=s2>&#34;&#34;&#34;可视化点云&#34;&#34;&#34;</span>
    <span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>([</span><span class=n>pcd1</span><span class=p>,</span> <span class=n>pcd2</span><span class=p>],</span> <span class=n>window_name</span><span class=o>=</span><span class=n>window_name</span><span class=p>)</span>

<span class=c1># 生成并上色两个相似的点云</span>
<span class=n>pcd1</span> <span class=o>=</span> <span class=n>create_colored_point_cloud</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>])</span>  <span class=c1># 红色</span>
<span class=n>pcd2</span> <span class=o>=</span> <span class=n>create_colored_point_cloud</span><span class=p>([</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>])</span>  <span class=c1># 绿色</span>

<span class=c1># 对第二个点云进行初始变换</span>
<span class=n>initial_transformation</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([[</span><span class=mf>0.862</span><span class=p>,</span> <span class=mf>0.011</span><span class=p>,</span> <span class=o>-</span><span class=mf>0.507</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>],</span>
                                   <span class=p>[</span><span class=o>-</span><span class=mf>0.139</span><span class=p>,</span> <span class=mf>0.967</span><span class=p>,</span> <span class=o>-</span><span class=mf>0.215</span><span class=p>,</span> <span class=mf>0.7</span><span class=p>],</span>
                                   <span class=p>[</span><span class=mf>0.487</span><span class=p>,</span> <span class=mf>0.255</span><span class=p>,</span> <span class=mf>0.835</span><span class=p>,</span> <span class=o>-</span><span class=mf>1.4</span><span class=p>],</span>
                                   <span class=p>[</span><span class=mf>0.0</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>]])</span>
<span class=n>pcd2</span><span class=o>.</span><span class=n>transform</span><span class=p>(</span><span class=n>initial_transformation</span><span class=p>)</span>

<span class=c1># 可视化初始点云</span>
<span class=n>visualize_point_clouds</span><span class=p>(</span><span class=n>pcd1</span><span class=p>,</span> <span class=n>pcd2</span><span class=p>,</span> <span class=s2>&#34;Initial Point Clouds&#34;</span><span class=p>)</span>

<span class=c1># 使用 ICP 进行配准</span>
<span class=n>threshold</span> <span class=o>=</span> <span class=mf>0.7</span>  <span class=c1># 增加阈值</span>
<span class=n>trans_init</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>eye</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span>
<span class=n>reg_p2p</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>pipelines</span><span class=o>.</span><span class=n>registration</span><span class=o>.</span><span class=n>registration_icp</span><span class=p>(</span>
    <span class=n>pcd1</span><span class=p>,</span> <span class=n>pcd2</span><span class=p>,</span> <span class=n>threshold</span><span class=p>,</span> <span class=n>trans_init</span><span class=p>,</span>
    <span class=n>o3d</span><span class=o>.</span><span class=n>pipelines</span><span class=o>.</span><span class=n>registration</span><span class=o>.</span><span class=n>TransformationEstimationPointToPoint</span><span class=p>()</span>
<span class=p>)</span>

<span class=c1># 打印配准信息</span>
<span class=k>print</span><span class=p>(</span><span class=s2>&#34;ICP converged:&#34;</span><span class=p>,</span> <span class=n>reg_p2p</span><span class=o>.</span><span class=n>inlier_rmse</span> <span class=o>&lt;</span> <span class=n>threshold</span><span class=p>)</span>
<span class=k>print</span><span class=p>(</span><span class=s2>&#34;Fitness:&#34;</span><span class=p>,</span> <span class=n>reg_p2p</span><span class=o>.</span><span class=n>fitness</span><span class=p>)</span>
<span class=k>print</span><span class=p>(</span><span class=s2>&#34;Inlier RMSE:&#34;</span><span class=p>,</span> <span class=n>reg_p2p</span><span class=o>.</span><span class=n>inlier_rmse</span><span class=p>)</span>
<span class=k>print</span><span class=p>(</span><span class=s2>&#34;Transformation matrix:&#34;</span><span class=p>)</span>
<span class=k>print</span><span class=p>(</span><span class=n>reg_p2p</span><span class=o>.</span><span class=n>transformation</span><span class=p>)</span>

<span class=c1># 计算逆矩阵</span>
<span class=n>inverse_transformation</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linalg</span><span class=o>.</span><span class=n>inv</span><span class=p>(</span><span class=n>reg_p2p</span><span class=o>.</span><span class=n>transformation</span><span class=p>)</span>

<span class=c1># 应用逆矩阵到第二个点云</span>
<span class=n>pcd2</span><span class=o>.</span><span class=n>transform</span><span class=p>(</span><span class=n>inverse_transformation</span><span class=p>)</span>

<span class=c1># 可视化配准后的点云</span>
<span class=n>visualize_point_clouds</span><span class=p>(</span><span class=n>pcd1</span><span class=p>,</span> <span class=n>pcd2</span><span class=p>,</span> <span class=s2>&#34;Aligned Point Clouds&#34;</span><span class=p>)</span>

</code></pre></div><table><thead><tr><th>原始点云</th><th>配准点云</th></tr></thead><tbody><tr><td><figure><img src=reg_p2p_1.png alt=reg_p2p_1 loading=lazy></figure></td><td><figure><img src=reg_p2p_2.png alt=reg_p2p_2 loading=lazy></figure></td></tr></tbody></table><h2 id=102-colored-icp-配准>10.2 Colored ICP 配准<a hidden class=anchor aria-hidden=true href=#102-colored-icp-配准>#</a></h2><p><strong>说明</strong>：在传统 ICP 的基础上，考虑了颜色信息来进行配准。</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>open3d</span> <span class=kn>as</span> <span class=nn>o3d</span>
<span class=kn>import</span> <span class=nn>numpy</span> <span class=kn>as</span> <span class=nn>np</span>

<span class=k>def</span> <span class=nf>create_colored_sphere</span><span class=p>(</span><span class=n>radius</span><span class=p>,</span> <span class=n>color</span><span class=p>,</span> <span class=n>density</span><span class=o>=</span><span class=mi>1000</span><span class=p>):</span>
    <span class=n>mesh</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>TriangleMesh</span><span class=o>.</span><span class=n>create_sphere</span><span class=p>(</span><span class=n>radius</span><span class=o>=</span><span class=n>radius</span><span class=p>)</span>
    <span class=n>pcd</span> <span class=o>=</span> <span class=n>mesh</span><span class=o>.</span><span class=n>sample_points_poisson_disk</span><span class=p>(</span><span class=n>number_of_points</span><span class=o>=</span><span class=n>density</span><span class=p>)</span>
    <span class=n>pcd</span><span class=o>.</span><span class=n>paint_uniform_color</span><span class=p>(</span><span class=n>color</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>pcd</span>

<span class=k>def</span> <span class=nf>estimate_normals</span><span class=p>(</span><span class=n>pcd</span><span class=p>,</span> <span class=n>radius</span><span class=o>=</span><span class=mf>0.1</span><span class=p>,</span> <span class=n>max_nn</span><span class=o>=</span><span class=mi>30</span><span class=p>):</span>
    <span class=n>pcd</span><span class=o>.</span><span class=n>estimate_normals</span><span class=p>(</span><span class=n>search_param</span><span class=o>=</span><span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>KDTreeSearchParamHybrid</span><span class=p>(</span><span class=n>radius</span><span class=o>=</span><span class=n>radius</span><span class=p>,</span> <span class=n>max_nn</span><span class=o>=</span><span class=n>max_nn</span><span class=p>))</span>

<span class=k>def</span> <span class=nf>execute_colored_icp</span><span class=p>(</span><span class=n>source</span><span class=p>,</span> <span class=n>target</span><span class=p>,</span> <span class=n>max_correspondence_distance</span><span class=p>,</span> <span class=n>initial_transformation</span><span class=p>):</span>
    <span class=n>criteria</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>pipelines</span><span class=o>.</span><span class=n>registration</span><span class=o>.</span><span class=n>ICPConvergenceCriteria</span><span class=p>(</span>
        <span class=n>relative_fitness</span><span class=o>=</span><span class=mf>1e-3</span><span class=p>,</span>
        <span class=n>relative_rmse</span><span class=o>=</span><span class=mf>1e-3</span><span class=p>,</span>
        <span class=n>max_iteration</span><span class=o>=</span><span class=mi>500</span><span class=p>)</span>
    <span class=n>result</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>pipelines</span><span class=o>.</span><span class=n>registration</span><span class=o>.</span><span class=n>registration_colored_icp</span><span class=p>(</span>
        <span class=n>source</span><span class=p>,</span> <span class=n>target</span><span class=p>,</span> <span class=n>max_correspondence_distance</span><span class=p>,</span> <span class=n>initial_transformation</span><span class=p>,</span>
        <span class=n>o3d</span><span class=o>.</span><span class=n>pipelines</span><span class=o>.</span><span class=n>registration</span><span class=o>.</span><span class=n>TransformationEstimationForColoredICP</span><span class=p>(),</span>
        <span class=n>criteria</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>result</span>

<span class=c1># 创建两个绿色的球体</span>
<span class=n>sphere1</span> <span class=o>=</span> <span class=n>create_colored_sphere</span><span class=p>(</span><span class=mf>1.0</span><span class=p>,</span> <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>],</span> <span class=n>density</span><span class=o>=</span><span class=mi>1000</span><span class=p>)</span>
<span class=n>sphere2</span> <span class=o>=</span> <span class=n>create_colored_sphere</span><span class=p>(</span><span class=mf>1.0</span><span class=p>,</span> <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>],</span> <span class=n>density</span><span class=o>=</span><span class=mi>1000</span><span class=p>)</span>

<span class=c1># 对第二个球体进行变换</span>
<span class=n>transformation</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([[</span><span class=mf>0.862</span><span class=p>,</span> <span class=mf>0.011</span><span class=p>,</span> <span class=o>-</span><span class=mf>0.507</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>],</span>
                           <span class=p>[</span><span class=o>-</span><span class=mf>0.139</span><span class=p>,</span> <span class=mf>0.967</span><span class=p>,</span> <span class=o>-</span><span class=mf>0.215</span><span class=p>,</span> <span class=mf>0.7</span><span class=p>],</span>
                           <span class=p>[</span><span class=mf>0.487</span><span class=p>,</span> <span class=mf>0.255</span><span class=p>,</span> <span class=mf>0.835</span><span class=p>,</span> <span class=o>-</span><span class=mf>1.4</span><span class=p>],</span>
                           <span class=p>[</span><span class=mf>0.0</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>]])</span>
<span class=n>sphere2</span><span class=o>.</span><span class=n>transform</span><span class=p>(</span><span class=n>transformation</span><span class=p>)</span>

<span class=c1># 估算法线</span>
<span class=n>estimate_normals</span><span class=p>(</span><span class=n>sphere1</span><span class=p>)</span>
<span class=n>estimate_normals</span><span class=p>(</span><span class=n>sphere2</span><span class=p>)</span>

<span class=c1># 可视化配准前的点云</span>
<span class=k>print</span><span class=p>(</span><span class=s2>&#34;配准前的点云：&#34;</span><span class=p>)</span>
<span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>([</span><span class=n>sphere1</span><span class=p>,</span> <span class=n>sphere2</span><span class=p>],</span> <span class=n>window_name</span><span class=o>=</span><span class=s2>&#34;Before Registration&#34;</span><span class=p>)</span>

<span class=c1># 使用彩色ICP进行配准</span>
<span class=n>max_correspondence_distance</span> <span class=o>=</span> <span class=mf>5.0</span>  <span class=c1># 增大最大对应点距离</span>
<span class=n>initial_transformation</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>identity</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span>
<span class=n>result_colored_icp</span> <span class=o>=</span> <span class=n>execute_colored_icp</span><span class=p>(</span><span class=n>sphere1</span><span class=p>,</span> <span class=n>sphere2</span><span class=p>,</span> <span class=n>max_correspondence_distance</span><span class=p>,</span> <span class=n>initial_transformation</span><span class=p>)</span>

<span class=c1># 应用变换到第一个球体点云</span>
<span class=n>sphere1</span><span class=o>.</span><span class=n>transform</span><span class=p>(</span><span class=n>result_colored_icp</span><span class=o>.</span><span class=n>transformation</span><span class=p>)</span>

<span class=c1># 可视化配准后的点云</span>
<span class=k>print</span><span class=p>(</span><span class=s2>&#34;配准后的点云：&#34;</span><span class=p>)</span>
<span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>([</span><span class=n>sphere1</span><span class=p>,</span> <span class=n>sphere2</span><span class=p>],</span> <span class=n>window_name</span><span class=o>=</span><span class=s2>&#34;After Registration&#34;</span><span class=p>)</span>
</code></pre></div><ul><li><strong>代码说明</strong>：</li></ul><ol><li><strong>创建彩色球体</strong>：使用 <code>create_colored_sphere</code> 函数创建两个绿色的球体。</li><li><strong>对第二个球体进行变换</strong>：对第二个球体进行随机变换。</li><li><strong>估算法线</strong>：计算球体点云的法线。</li><li><strong>可视化配准前的点云</strong>：在配准前显示两个球体点云。</li><li><strong>使用彩色ICP进行配准</strong>：使用彩色ICP算法进行配准。</li><li><strong>应用变换到第一个球体点云</strong>：将配准结果应用到第一个球体点云。</li><li><strong>可视化配准后的点云</strong>：在配准后显示两个球体点云。</li></ol><table><thead><tr><th>原始点云</th><th>配准点云</th></tr></thead><tbody><tr><td><figure><img src=reg_p2p_3.png alt=reg_p2p_3 loading=lazy></figure></td><td><figure><img src=reg_p2p_4.png alt=reg_p2p_4 loading=lazy></figure></td></tr></tbody></table><h2 id=103-全局配准>10.3 全局配准<a hidden class=anchor aria-hidden=true href=#103-全局配准>#</a></h2><p><strong>说明</strong>：用于初始配准，通常在没有初始对齐的情况下使用。</p><p>好的，以下是包含配准前后可视化的完整代码：</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>open3d</span> <span class=kn>as</span> <span class=nn>o3d</span>
<span class=kn>import</span> <span class=nn>numpy</span> <span class=kn>as</span> <span class=nn>np</span>

<span class=c1># 生成点云数据</span>
<span class=k>def</span> <span class=nf>generate_point_cloud</span><span class=p>():</span>
    <span class=c1># 创建一个球体点云</span>
    <span class=n>mesh</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>TriangleMesh</span><span class=o>.</span><span class=n>create_sphere</span><span class=p>(</span><span class=n>radius</span><span class=o>=</span><span class=mf>1.0</span><span class=p>)</span>
    <span class=n>pcd</span> <span class=o>=</span> <span class=n>mesh</span><span class=o>.</span><span class=n>sample_points_poisson_disk</span><span class=p>(</span><span class=n>number_of_points</span><span class=o>=</span><span class=mi>500</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>pcd</span>

<span class=c1># 生成源点云和目标点云</span>
<span class=n>source</span> <span class=o>=</span> <span class=n>generate_point_cloud</span><span class=p>()</span>
<span class=n>target</span> <span class=o>=</span> <span class=n>generate_point_cloud</span><span class=p>()</span>

<span class=c1># 对目标点云进行随机变换</span>
<span class=n>transformation</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([[</span><span class=mf>0.862</span><span class=p>,</span> <span class=mf>0.011</span><span class=p>,</span> <span class=o>-</span><span class=mf>0.507</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>],</span>
                           <span class=p>[</span><span class=o>-</span><span class=mf>0.139</span><span class=p>,</span> <span class=mf>0.967</span><span class=p>,</span> <span class=o>-</span><span class=mf>0.215</span><span class=p>,</span> <span class=mf>0.7</span><span class=p>],</span>
                           <span class=p>[</span><span class=mf>0.487</span><span class=p>,</span> <span class=mf>0.255</span><span class=p>,</span> <span class=mf>0.835</span><span class=p>,</span> <span class=o>-</span><span class=mf>1.4</span><span class=p>],</span>
                           <span class=p>[</span><span class=mf>0.0</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>]])</span>
<span class=n>target</span><span class=o>.</span><span class=n>transform</span><span class=p>(</span><span class=n>transformation</span><span class=p>)</span>

<span class=c1># 下采样点云</span>
<span class=n>voxel_size</span> <span class=o>=</span> <span class=mf>0.05</span>
<span class=n>source_down</span> <span class=o>=</span> <span class=n>source</span><span class=o>.</span><span class=n>voxel_down_sample</span><span class=p>(</span><span class=n>voxel_size</span><span class=p>)</span>
<span class=n>target_down</span> <span class=o>=</span> <span class=n>target</span><span class=o>.</span><span class=n>voxel_down_sample</span><span class=p>(</span><span class=n>voxel_size</span><span class=p>)</span>

<span class=c1># 估计法线</span>
<span class=n>source_down</span><span class=o>.</span><span class=n>estimate_normals</span><span class=p>(</span><span class=n>search_param</span><span class=o>=</span><span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>KDTreeSearchParamHybrid</span><span class=p>(</span><span class=n>radius</span><span class=o>=</span><span class=mf>0.1</span><span class=p>,</span> <span class=n>max_nn</span><span class=o>=</span><span class=mi>30</span><span class=p>))</span>
<span class=n>target_down</span><span class=o>.</span><span class=n>estimate_normals</span><span class=p>(</span><span class=n>search_param</span><span class=o>=</span><span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>KDTreeSearchParamHybrid</span><span class=p>(</span><span class=n>radius</span><span class=o>=</span><span class=mf>0.1</span><span class=p>,</span> <span class=n>max_nn</span><span class=o>=</span><span class=mi>30</span><span class=p>))</span>

<span class=c1># 计算FPFH特征</span>
<span class=n>source_fpfh</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>pipelines</span><span class=o>.</span><span class=n>registration</span><span class=o>.</span><span class=n>compute_fpfh_feature</span><span class=p>(</span>
    <span class=n>source_down</span><span class=p>,</span>
    <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>KDTreeSearchParamHybrid</span><span class=p>(</span><span class=n>radius</span><span class=o>=</span><span class=mf>0.25</span><span class=p>,</span> <span class=n>max_nn</span><span class=o>=</span><span class=mi>100</span><span class=p>))</span>
<span class=n>target_fpfh</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>pipelines</span><span class=o>.</span><span class=n>registration</span><span class=o>.</span><span class=n>compute_fpfh_feature</span><span class=p>(</span>
    <span class=n>target_down</span><span class=p>,</span>
    <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>KDTreeSearchParamHybrid</span><span class=p>(</span><span class=n>radius</span><span class=o>=</span><span class=mf>0.25</span><span class=p>,</span> <span class=n>max_nn</span><span class=o>=</span><span class=mi>100</span><span class=p>))</span>

<span class=c1># 使用RANSAC进行全局配准</span>
<span class=n>result_ransac</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>pipelines</span><span class=o>.</span><span class=n>registration</span><span class=o>.</span><span class=n>registration_ransac_based_on_feature_matching</span><span class=p>(</span>
    <span class=n>source_down</span><span class=p>,</span> <span class=n>target_down</span><span class=p>,</span> <span class=n>source_fpfh</span><span class=p>,</span> <span class=n>target_fpfh</span><span class=p>,</span>
    <span class=n>mutual_filter</span><span class=o>=</span><span class=bp>True</span><span class=p>,</span>
    <span class=n>max_correspondence_distance</span><span class=o>=</span><span class=mf>0.15</span><span class=p>,</span>
    <span class=n>estimation_method</span><span class=o>=</span><span class=n>o3d</span><span class=o>.</span><span class=n>pipelines</span><span class=o>.</span><span class=n>registration</span><span class=o>.</span><span class=n>TransformationEstimationPointToPoint</span><span class=p>(</span><span class=bp>False</span><span class=p>),</span>
    <span class=n>ransac_n</span><span class=o>=</span><span class=mi>4</span><span class=p>,</span>
    <span class=n>checkers</span><span class=o>=</span><span class=p>[</span><span class=n>o3d</span><span class=o>.</span><span class=n>pipelines</span><span class=o>.</span><span class=n>registration</span><span class=o>.</span><span class=n>CorrespondenceCheckerBasedOnEdgeLength</span><span class=p>(</span><span class=mf>0.9</span><span class=p>),</span>
              <span class=n>o3d</span><span class=o>.</span><span class=n>pipelines</span><span class=o>.</span><span class=n>registration</span><span class=o>.</span><span class=n>CorrespondenceCheckerBasedOnDistance</span><span class=p>(</span><span class=mf>0.15</span><span class=p>)],</span>
    <span class=n>criteria</span><span class=o>=</span><span class=n>o3d</span><span class=o>.</span><span class=n>pipelines</span><span class=o>.</span><span class=n>registration</span><span class=o>.</span><span class=n>RANSACConvergenceCriteria</span><span class=p>(</span><span class=mi>4000000</span><span class=p>,</span> <span class=mi>500</span><span class=p>))</span>

<span class=k>print</span><span class=p>(</span><span class=n>result_ransac</span><span class=p>)</span>

<span class=c1># 可视化配准前的点云</span>
<span class=n>source_temp</span> <span class=o>=</span> <span class=n>source_down</span><span class=o>.</span><span class=n>transform</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>identity</span><span class=p>(</span><span class=mi>4</span><span class=p>))</span>  <span class=c1># 恢复原始位置</span>
<span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>([</span><span class=n>source_temp</span><span class=p>,</span> <span class=n>target_down</span><span class=p>],</span> <span class=n>window_name</span><span class=o>=</span><span class=s2>&#34;配准前&#34;</span><span class=p>)</span>

<span class=c1># 可视化配准后的点云</span>
<span class=n>source_temp</span> <span class=o>=</span> <span class=n>source_down</span><span class=o>.</span><span class=n>transform</span><span class=p>(</span><span class=n>result_ransac</span><span class=o>.</span><span class=n>transformation</span><span class=p>)</span>
<span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>([</span><span class=n>source_temp</span><span class=p>,</span> <span class=n>target_down</span><span class=p>],</span> <span class=n>window_name</span><span class=o>=</span><span class=s2>&#34;配准后&#34;</span><span class=p>)</span>
</code></pre></div><ul><li><strong>代码说明</strong>：</li></ul><ol><li><strong>生成点云数据</strong>：创建一个球体点云，并对目标点云进行随机变换。</li><li><strong>下采样点云</strong>：对点云进行体素下采样，以减少计算量。</li><li><strong>估计法线</strong>：计算点云的法线。</li><li><strong>计算FPFH特征</strong>：计算快速点特征直方图（FPFH）特征。</li><li><strong>使用RANSAC进行全局配准</strong>：使用 RANSAC 算法基于特征匹配进行全局配准。</li><li><strong>可视化配准前的点云</strong>：在配准前显示源点云和目标点云。</li><li><strong>可视化配准后的点云</strong>：在配准后显示源点云和目标点云。</li></ol><table><thead><tr><th>初始点云</th><th>配准点云</th></tr></thead><tbody><tr><td><figure><img src=reg_p2p_5.png alt=reg_p2p_5 loading=lazy></figure></td><td><figure><img src=reg_p2p_6.png alt=reg_p2p_6 loading=lazy></figure></td></tr><tr><td></td><td></td></tr></tbody></table><h2 id=104-多路配准>10.4 多路配准<a hidden class=anchor aria-hidden=true href=#104-多路配准>#</a></h2><p><strong>说明</strong>：用于将多个点云配准到一个共同的参考框架中。</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>open3d</span> <span class=kn>as</span> <span class=nn>o3d</span>
<span class=kn>import</span> <span class=nn>numpy</span> <span class=kn>as</span> <span class=nn>np</span>

<span class=k>def</span> <span class=nf>create_colored_sphere</span><span class=p>(</span><span class=n>radius</span><span class=p>,</span> <span class=n>color</span><span class=p>,</span> <span class=n>density</span><span class=o>=</span><span class=mi>1000</span><span class=p>):</span>
    <span class=n>mesh</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>TriangleMesh</span><span class=o>.</span><span class=n>create_sphere</span><span class=p>(</span><span class=n>radius</span><span class=o>=</span><span class=n>radius</span><span class=p>)</span>
    <span class=n>pcd</span> <span class=o>=</span> <span class=n>mesh</span><span class=o>.</span><span class=n>sample_points_poisson_disk</span><span class=p>(</span><span class=n>number_of_points</span><span class=o>=</span><span class=n>density</span><span class=p>)</span>
    <span class=n>pcd</span><span class=o>.</span><span class=n>paint_uniform_color</span><span class=p>(</span><span class=n>color</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>pcd</span>

<span class=k>def</span> <span class=nf>preprocess_point_cloud</span><span class=p>(</span><span class=n>pcd</span><span class=p>,</span> <span class=n>voxel_size</span><span class=p>):</span>
    <span class=n>pcd_down</span> <span class=o>=</span> <span class=n>pcd</span><span class=o>.</span><span class=n>voxel_down_sample</span><span class=p>(</span><span class=n>voxel_size</span><span class=p>)</span>
    <span class=n>radius_normal</span> <span class=o>=</span> <span class=n>voxel_size</span> <span class=o>*</span> <span class=mi>2</span>
    <span class=n>pcd_down</span><span class=o>.</span><span class=n>estimate_normals</span><span class=p>(</span><span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>KDTreeSearchParamHybrid</span><span class=p>(</span><span class=n>radius</span><span class=o>=</span><span class=n>radius_normal</span><span class=p>,</span> <span class=n>max_nn</span><span class=o>=</span><span class=mi>30</span><span class=p>))</span>
    <span class=n>radius_feature</span> <span class=o>=</span> <span class=n>voxel_size</span> <span class=o>*</span> <span class=mi>5</span>
    <span class=n>pcd_fpfh</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>pipelines</span><span class=o>.</span><span class=n>registration</span><span class=o>.</span><span class=n>compute_fpfh_feature</span><span class=p>(</span>
        <span class=n>pcd_down</span><span class=p>,</span>
        <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>KDTreeSearchParamHybrid</span><span class=p>(</span><span class=n>radius</span><span class=o>=</span><span class=n>radius_feature</span><span class=p>,</span> <span class=n>max_nn</span><span class=o>=</span><span class=mi>100</span><span class=p>))</span>
    <span class=k>return</span> <span class=n>pcd_down</span><span class=p>,</span> <span class=n>pcd_fpfh</span>

<span class=k>def</span> <span class=nf>pairwise_registration</span><span class=p>(</span><span class=n>source</span><span class=p>,</span> <span class=n>target</span><span class=p>,</span> <span class=n>voxel_size</span><span class=p>):</span>
    <span class=n>source_down</span><span class=p>,</span> <span class=n>source_fpfh</span> <span class=o>=</span> <span class=n>preprocess_point_cloud</span><span class=p>(</span><span class=n>source</span><span class=p>,</span> <span class=n>voxel_size</span><span class=p>)</span>
    <span class=n>target_down</span><span class=p>,</span> <span class=n>target_fpfh</span> <span class=o>=</span> <span class=n>preprocess_point_cloud</span><span class=p>(</span><span class=n>target</span><span class=p>,</span> <span class=n>voxel_size</span><span class=p>)</span>

    <span class=n>distance_threshold</span> <span class=o>=</span> <span class=n>voxel_size</span> <span class=o>*</span> <span class=mf>1.5</span>
    <span class=n>result</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>pipelines</span><span class=o>.</span><span class=n>registration</span><span class=o>.</span><span class=n>registration_ransac_based_on_feature_matching</span><span class=p>(</span>
        <span class=n>source_down</span><span class=p>,</span> <span class=n>target_down</span><span class=p>,</span> <span class=n>source_fpfh</span><span class=p>,</span> <span class=n>target_fpfh</span><span class=p>,</span> <span class=bp>True</span><span class=p>,</span>
        <span class=n>distance_threshold</span><span class=p>,</span>
        <span class=n>o3d</span><span class=o>.</span><span class=n>pipelines</span><span class=o>.</span><span class=n>registration</span><span class=o>.</span><span class=n>TransformationEstimationPointToPoint</span><span class=p>(</span><span class=bp>False</span><span class=p>),</span>
        <span class=mi>4</span><span class=p>,</span> <span class=p>[</span>
            <span class=n>o3d</span><span class=o>.</span><span class=n>pipelines</span><span class=o>.</span><span class=n>registration</span><span class=o>.</span><span class=n>CorrespondenceCheckerBasedOnEdgeLength</span><span class=p>(</span><span class=mf>0.9</span><span class=p>),</span>
            <span class=n>o3d</span><span class=o>.</span><span class=n>pipelines</span><span class=o>.</span><span class=n>registration</span><span class=o>.</span><span class=n>CorrespondenceCheckerBasedOnDistance</span><span class=p>(</span><span class=n>distance_threshold</span><span class=p>)</span>
        <span class=p>],</span> <span class=n>o3d</span><span class=o>.</span><span class=n>pipelines</span><span class=o>.</span><span class=n>registration</span><span class=o>.</span><span class=n>RANSACConvergenceCriteria</span><span class=p>(</span><span class=mi>4000000</span><span class=p>,</span> <span class=mi>500</span><span class=p>))</span>
    <span class=k>return</span> <span class=n>result</span>

<span class=k>def</span> <span class=nf>full_registration</span><span class=p>(</span><span class=n>pcds</span><span class=p>,</span> <span class=n>voxel_size</span><span class=p>):</span>
    <span class=n>pose_graph</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>pipelines</span><span class=o>.</span><span class=n>registration</span><span class=o>.</span><span class=n>PoseGraph</span><span class=p>()</span>
    <span class=n>odometry</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>identity</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span>
    <span class=n>pose_graph</span><span class=o>.</span><span class=n>nodes</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>o3d</span><span class=o>.</span><span class=n>pipelines</span><span class=o>.</span><span class=n>registration</span><span class=o>.</span><span class=n>PoseGraphNode</span><span class=p>(</span><span class=n>odometry</span><span class=p>))</span>

    <span class=k>for</span> <span class=n>source_id</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>pcds</span><span class=p>)):</span>
        <span class=k>for</span> <span class=n>target_id</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>source_id</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>pcds</span><span class=p>)):</span>
            <span class=n>result</span> <span class=o>=</span> <span class=n>pairwise_registration</span><span class=p>(</span><span class=n>pcds</span><span class=p>[</span><span class=n>source_id</span><span class=p>],</span> <span class=n>pcds</span><span class=p>[</span><span class=n>target_id</span><span class=p>],</span> <span class=n>voxel_size</span><span class=p>)</span>
            <span class=n>trans</span> <span class=o>=</span> <span class=n>result</span><span class=o>.</span><span class=n>transformation</span>
            <span class=n>information</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>pipelines</span><span class=o>.</span><span class=n>registration</span><span class=o>.</span><span class=n>get_information_matrix_from_point_clouds</span><span class=p>(</span>
                <span class=n>pcds</span><span class=p>[</span><span class=n>source_id</span><span class=p>],</span> <span class=n>pcds</span><span class=p>[</span><span class=n>target_id</span><span class=p>],</span> <span class=n>voxel_size</span> <span class=o>*</span> <span class=mf>1.5</span><span class=p>,</span> <span class=n>result</span><span class=o>.</span><span class=n>transformation</span><span class=p>)</span>
            <span class=k>if</span> <span class=n>target_id</span> <span class=o>==</span> <span class=n>source_id</span> <span class=o>+</span> <span class=mi>1</span><span class=p>:</span>
                <span class=n>odometry</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>dot</span><span class=p>(</span><span class=n>trans</span><span class=p>,</span> <span class=n>odometry</span><span class=p>)</span>
                <span class=n>pose_graph</span><span class=o>.</span><span class=n>nodes</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>o3d</span><span class=o>.</span><span class=n>pipelines</span><span class=o>.</span><span class=n>registration</span><span class=o>.</span><span class=n>PoseGraphNode</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>linalg</span><span class=o>.</span><span class=n>inv</span><span class=p>(</span><span class=n>odometry</span><span class=p>)))</span>
                <span class=n>pose_graph</span><span class=o>.</span><span class=n>edges</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>o3d</span><span class=o>.</span><span class=n>pipelines</span><span class=o>.</span><span class=n>registration</span><span class=o>.</span><span class=n>PoseGraphEdge</span><span class=p>(</span><span class=n>source_id</span><span class=p>,</span> <span class=n>target_id</span><span class=p>,</span> <span class=n>trans</span><span class=p>,</span> <span class=n>information</span><span class=p>,</span> <span class=n>uncertain</span><span class=o>=</span><span class=bp>False</span><span class=p>))</span>
            <span class=k>else</span><span class=p>:</span>
                <span class=n>pose_graph</span><span class=o>.</span><span class=n>edges</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>o3d</span><span class=o>.</span><span class=n>pipelines</span><span class=o>.</span><span class=n>registration</span><span class=o>.</span><span class=n>PoseGraphEdge</span><span class=p>(</span><span class=n>source_id</span><span class=p>,</span> <span class=n>target_id</span><span class=p>,</span> <span class=n>trans</span><span class=p>,</span> <span class=n>information</span><span class=p>,</span> <span class=n>uncertain</span><span class=o>=</span><span class=bp>True</span><span class=p>))</span>
    <span class=k>return</span> <span class=n>pose_graph</span>

<span class=k>def</span> <span class=nf>run_global_optimization</span><span class=p>(</span><span class=n>pose_graph</span><span class=p>):</span>
    <span class=n>option</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>pipelines</span><span class=o>.</span><span class=n>registration</span><span class=o>.</span><span class=n>GlobalOptimizationOption</span><span class=p>(</span>
        <span class=n>max_correspondence_distance</span><span class=o>=</span><span class=mf>0.02</span><span class=p>,</span>
        <span class=n>edge_prune_threshold</span><span class=o>=</span><span class=mf>0.25</span><span class=p>,</span>
        <span class=n>reference_node</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>
    <span class=n>o3d</span><span class=o>.</span><span class=n>pipelines</span><span class=o>.</span><span class=n>registration</span><span class=o>.</span><span class=n>global_optimization</span><span class=p>(</span>
        <span class=n>pose_graph</span><span class=p>,</span>
        <span class=n>o3d</span><span class=o>.</span><span class=n>pipelines</span><span class=o>.</span><span class=n>registration</span><span class=o>.</span><span class=n>GlobalOptimizationLevenbergMarquardt</span><span class=p>(),</span>
        <span class=n>o3d</span><span class=o>.</span><span class=n>pipelines</span><span class=o>.</span><span class=n>registration</span><span class=o>.</span><span class=n>GlobalOptimizationConvergenceCriteria</span><span class=p>(),</span>
        <span class=n>option</span><span class=p>)</span>

<span class=k>def</span> <span class=nf>merge_point_clouds</span><span class=p>(</span><span class=n>pcds</span><span class=p>,</span> <span class=n>pose_graph</span><span class=p>):</span>
    <span class=n>pcd_combined</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>PointCloud</span><span class=p>()</span>
    <span class=k>for</span> <span class=n>point_id</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>pcds</span><span class=p>)):</span>
        <span class=n>pcd_transformed</span> <span class=o>=</span> <span class=n>pcds</span><span class=p>[</span><span class=n>point_id</span><span class=p>]</span><span class=o>.</span><span class=n>transform</span><span class=p>(</span><span class=n>pose_graph</span><span class=o>.</span><span class=n>nodes</span><span class=p>[</span><span class=n>point_id</span><span class=p>]</span><span class=o>.</span><span class=n>pose</span><span class=p>)</span>
        <span class=n>pcd_combined</span> <span class=o>+=</span> <span class=n>pcd_transformed</span>
    <span class=k>return</span> <span class=n>pcd_combined</span>

<span class=c1># 创建不同颜色和大小的球体</span>
<span class=n>sphere1</span> <span class=o>=</span> <span class=n>create_colored_sphere</span><span class=p>(</span><span class=mf>1.0</span><span class=p>,</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>],</span> <span class=n>density</span><span class=o>=</span><span class=mi>1000</span><span class=p>)</span>  <span class=c1># 红色球体</span>
<span class=n>sphere2</span> <span class=o>=</span> <span class=n>create_colored_sphere</span><span class=p>(</span><span class=mf>0.8</span><span class=p>,</span> <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>],</span> <span class=n>density</span><span class=o>=</span><span class=mi>1000</span><span class=p>)</span>  <span class=c1># 绿色球体</span>
<span class=n>sphere3</span> <span class=o>=</span> <span class=n>create_colored_sphere</span><span class=p>(</span><span class=mf>0.6</span><span class=p>,</span> <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>],</span> <span class=n>density</span><span class=o>=</span><span class=mi>1000</span><span class=p>)</span>  <span class=c1># 蓝色球体</span>

<span class=c1># 对球体进行随机变换</span>
<span class=n>transformation1</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([[</span><span class=mf>0.862</span><span class=p>,</span> <span class=mf>0.011</span><span class=p>,</span> <span class=o>-</span><span class=mf>0.507</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>],</span>
                            <span class=p>[</span><span class=o>-</span><span class=mf>0.139</span><span class=p>,</span> <span class=mf>0.967</span><span class=p>,</span> <span class=o>-</span><span class=mf>0.215</span><span class=p>,</span> <span class=mf>0.7</span><span class=p>],</span>
                            <span class=p>[</span><span class=mf>0.487</span><span class=p>,</span> <span class=mf>0.255</span><span class=p>,</span> <span class=mf>0.835</span><span class=p>,</span> <span class=o>-</span><span class=mf>1.4</span><span class=p>],</span>
                            <span class=p>[</span><span class=mf>0.0</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>]])</span>
<span class=n>sphere2</span><span class=o>.</span><span class=n>transform</span><span class=p>(</span><span class=n>transformation1</span><span class=p>)</span>

<span class=n>transformation2</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([[</span><span class=mf>0.707</span><span class=p>,</span> <span class=o>-</span><span class=mf>0.707</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>],</span>
                            <span class=p>[</span><span class=mf>0.707</span><span class=p>,</span> <span class=mf>0.707</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>],</span>
                            <span class=p>[</span><span class=mf>0.0</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>,</span> <span class=o>-</span><span class=mf>0.5</span><span class=p>],</span>
                            <span class=p>[</span><span class=mf>0.0</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>]])</span>
<span class=n>sphere3</span><span class=o>.</span><span class=n>transform</span><span class=p>(</span><span class=n>transformation2</span><span class=p>)</span>

<span class=n>pcds</span> <span class=o>=</span> <span class=p>[</span><span class=n>sphere1</span><span class=p>,</span> <span class=n>sphere2</span><span class=p>,</span> <span class=n>sphere3</span><span class=p>]</span>

<span class=c1># 设置体素大小</span>
<span class=n>voxel_size</span> <span class=o>=</span> <span class=mf>0.05</span>

<span class=c1># 可视化配准前的点云</span>
<span class=k>print</span><span class=p>(</span><span class=s2>&#34;配准前的点云&#34;</span><span class=p>)</span>
<span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>(</span><span class=n>pcds</span><span class=p>,</span> <span class=n>window_name</span><span class=o>=</span><span class=s2>&#34;Before Registration&#34;</span><span class=p>)</span>

<span class=c1># 进行多路配准</span>
<span class=n>pose_graph</span> <span class=o>=</span> <span class=n>full_registration</span><span class=p>(</span><span class=n>pcds</span><span class=p>,</span> <span class=n>voxel_size</span><span class=p>)</span>

<span class=c1># 运行全局优化</span>
<span class=n>run_global_optimization</span><span class=p>(</span><span class=n>pose_graph</span><span class=p>)</span>

<span class=c1># 合并点云</span>
<span class=n>pcd_combined</span> <span class=o>=</span> <span class=n>merge_point_clouds</span><span class=p>(</span><span class=n>pcds</span><span class=p>,</span> <span class=n>pose_graph</span><span class=p>)</span>

<span class=c1># 可视化配准后的点云</span>
<span class=k>print</span><span class=p>(</span><span class=s2>&#34;配准后的点云&#34;</span><span class=p>)</span>
<span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>([</span><span class=n>pcd_combined</span><span class=p>],</span> <span class=n>window_name</span><span class=o>=</span><span class=s2>&#34;After Registration&#34;</span><span class=p>)</span>
</code></pre></div><ul><li><strong>代码说明</strong>：</li></ul><ol><li><strong>创建彩色球体</strong>：使用 <code>create_colored_sphere</code> 函数创建不同颜色和大小的球体。</li><li><strong>对球体进行变换</strong>：对第二个和第三个球体进行随机变换。</li><li><strong>预处理点云</strong>：使用 <code>preprocess_point_cloud</code> 函数对点云进行下采样和特征提取。</li><li><strong>配对配准</strong>：使用 <code>pairwise_registration</code> 函数对两个点云进行配对配准。</li><li><strong>全局配准</strong>：使用 <code>full_registration</code> 函数对所有点云进行全局配准，构建位姿图。</li><li><strong>全局优化</strong>：使用 <code>run_global_optimization</code> 函数对位姿图进行全局优化。</li><li><strong>合并点云</strong>：使用 <code>merge_point_clouds</code> 函数将所有点云合并到一个全局坐标系中。</li><li><strong>可视化配准前的点云</strong>：使用 Open3D 的可视化工具显示配准前的点云。</li><li><strong>可视化配准后的点云</strong>：使用 Open3D 的可视化工具显示配准后的点云。</li></ol><table><thead><tr><th>原始点云</th><th>配准点云</th></tr></thead><tbody><tr><td><figure><img src=reg_p2p_7.png alt=reg_p2p_7 loading=lazy></figure></td><td><figure><img src=reg_p2p_8.png alt=reg_p2p_8 loading=lazy></figure></td></tr><tr><td></td><td></td></tr></tbody></table><p>这些案例展示了 Open3D 中不同点云配准方法的基本用法。</p><h1 id=11-点云表面重建>11. 点云表面重建<a hidden class=anchor aria-hidden=true href=#11-点云表面重建>#</a></h1><h2 id=111-alpha形状重建>11.1 Alpha形状重建<a hidden class=anchor aria-hidden=true href=#111-alpha形状重建>#</a></h2><p>Alpha形状重建是一种用于从点云数据生成三角网格的方法。它基于计算几何中的Alpha形状理论。Alpha形状是由Edelsbrunner等人在1983年提出的，它是Delaunay三角剖分的一个子集，用于描述点集的形状。</p><h3 id=1111-原理>11.1.1 原理<a hidden class=anchor aria-hidden=true href=#1111-原理>#</a></h3><ol><li><p><strong>Delaunay三角剖分</strong>：</p><ul><li>首先，对点云进行Delaunay三角剖分。Delaunay三角剖分是一种将点集划分为一系列三角形的算法，具有最大化最小角的性质，避免了瘦长三角形。</li></ul></li><li><p><strong>Alpha球</strong>：</p><ul><li>对于给定的参数α，定义一个半径为α的球（称为Alpha球）。Alpha球用于筛选Delaunay三角剖分中的三角形。</li></ul></li><li><p><strong>筛选三角形</strong>：</p><ul><li>对于每个Delaunay三角剖分中的三角形，检查其外接圆的半径。如果外接圆的半径小于或等于α，则保留该三角形；否则，丢弃该三角形。</li></ul></li><li><p><strong>生成Alpha形状</strong>：</p><ul><li>保留的三角形构成了Alpha形状。通过调整α的值，可以控制生成的形状的细节程度。较小的α值会生成更细致的形状，而较大的α值会生成更平滑的形状。</li></ul></li></ol><h3 id=1112-代码示例>11.1.2 代码示例<a hidden class=anchor aria-hidden=true href=#1112-代码示例>#</a></h3><p>以下是使用Open3D库进行Alpha形状重建的代码示例：</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>open3d</span> <span class=kn>as</span> <span class=nn>o3d</span>

<span class=c1># 读取点云</span>
<span class=n>pcd</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>io</span><span class=o>.</span><span class=n>read_point_cloud</span><span class=p>(</span><span class=s2>&#34;doll_1.ply&#34;</span><span class=p>)</span>

<span class=c1># 估计法线</span>
<span class=n>pcd</span><span class=o>.</span><span class=n>estimate_normals</span><span class=p>(</span><span class=n>search_param</span><span class=o>=</span><span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>KDTreeSearchParamHybrid</span><span class=p>(</span><span class=n>radius</span><span class=o>=</span><span class=mf>0.1</span><span class=p>,</span> <span class=n>max_nn</span><span class=o>=</span><span class=mi>30</span><span class=p>))</span>

<span class=c1># Alpha形状重建</span>
<span class=n>alpha</span> <span class=o>=</span> <span class=mf>0.03</span>  <span class=c1># 调整alpha值</span>
<span class=n>mesh_alpha</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>TriangleMesh</span><span class=o>.</span><span class=n>create_from_point_cloud_alpha_shape</span><span class=p>(</span><span class=n>pcd</span><span class=p>,</span> <span class=n>alpha</span><span class=p>)</span>

<span class=c1># 可视化Alpha形状重建结果</span>
<span class=n>mesh_alpha</span><span class=o>.</span><span class=n>compute_vertex_normals</span><span class=p>()</span>
<span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>([</span><span class=n>mesh_alpha</span><span class=p>],</span> <span class=n>window_name</span><span class=o>=</span><span class=n>f</span><span class=s2>&#34;Alpha Shape Reconstruction with alpha={alpha}&#34;</span><span class=p>)</span>
</code></pre></div><h3 id=1113-调整alpha值>11.1.3 调整Alpha值<a hidden class=anchor aria-hidden=true href=#1113-调整alpha值>#</a></h3><p>通过调整alpha值，可以生成不同细节程度的形状：</p><ul><li><strong>较小的alpha值</strong>：生成的形状更细致，保留更多的细节。</li><li><strong>较大的alpha值</strong>：生成的形状更平滑，去除了更多的细节。</li></ul><h3 id=1114-总结>11.1.4 总结<a hidden class=anchor aria-hidden=true href=#1114-总结>#</a></h3><p>Alpha形状重建是一种有效的从点云数据生成三角网格的方法，通过调整alpha值，可以控制生成形状的细节程度。它在计算几何和计算机图形学中有广泛的应用。</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>open3d</span> <span class=kn>as</span> <span class=nn>o3d</span>

<span class=c1># 读取点云</span>
<span class=n>pcd</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>io</span><span class=o>.</span><span class=n>read_point_cloud</span><span class=p>(</span><span class=s2>&#34;doll_1.ply&#34;</span><span class=p>)</span>

<span class=c1># 估计法线</span>
<span class=n>pcd</span><span class=o>.</span><span class=n>estimate_normals</span><span class=p>(</span><span class=n>search_param</span><span class=o>=</span><span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>KDTreeSearchParamHybrid</span><span class=p>(</span><span class=n>radius</span><span class=o>=</span><span class=mf>0.1</span><span class=p>,</span> <span class=n>max_nn</span><span class=o>=</span><span class=mi>30</span><span class=p>))</span>

<span class=c1># 调整Alpha形状重建参数</span>
<span class=k>print</span><span class=p>(</span><span class=s2>&#34;调整Alpha形状重建参数...&#34;</span><span class=p>)</span>
<span class=n>alphas</span> <span class=o>=</span> <span class=p>[</span><span class=mf>0.01</span><span class=p>,</span> <span class=mf>0.03</span><span class=p>,</span> <span class=mf>0.05</span><span class=p>]</span>
<span class=k>for</span> <span class=n>alpha</span> <span class=ow>in</span> <span class=n>alphas</span><span class=p>:</span>
    <span class=n>mesh_alpha</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>TriangleMesh</span><span class=o>.</span><span class=n>create_from_point_cloud_alpha_shape</span><span class=p>(</span><span class=n>pcd</span><span class=p>,</span> <span class=n>alpha</span><span class=p>)</span>
    <span class=n>mesh_alpha</span><span class=o>.</span><span class=n>compute_vertex_normals</span><span class=p>()</span>
    <span class=n>title</span> <span class=o>=</span> <span class=n>f</span><span class=s2>&#34;Alpha Shape Reconstruction with alpha={alpha}&#34;</span>
    <span class=k>print</span><span class=p>(</span><span class=n>title</span><span class=p>)</span>
    <span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>([</span><span class=n>mesh_alpha</span><span class=p>],</span> <span class=n>window_name</span><span class=o>=</span><span class=n>title</span><span class=p>)</span>
</code></pre></div><p><figure><img src=Alpha_1.png alt=Alpha_1 loading=lazy></figure><figure><img src=Alpha_2.png alt=Alpha_2 loading=lazy></figure><figure><img src=Alpha_3.png alt=Alpha_3 loading=lazy></figure></p><h2 id=112-泊松重建>11.2 泊松重建<a hidden class=anchor aria-hidden=true href=#112-泊松重建>#</a></h2><p>泊松重建（Poisson Surface Reconstruction）是一种从点云数据生成平滑三角网格的方法。它基于泊松方程，通过全局优化的方法生成表面，能够有效处理噪声和不完整的点云数据。</p><h3 id=1121-原理>11.2.1 原理<a hidden class=anchor aria-hidden=true href=#1121-原理>#</a></h3><ol><li><p><strong>法线估计</strong>：</p><ul><li>首先，从点云数据中估计每个点的法线方向。这一步通常使用邻域搜索算法，如KD树搜索。</li></ul></li><li><p><strong>泊松方程</strong>：
泊松重建的核心是求解泊松方程。泊松方程是一种偏微分方程，形式为：</p></li></ol><p>$$
\nabla \cdot \mathbf{V} = \rho
$$</p><p>其中，$\mathbf{V}$ 是一个向量场，$\rho$ 是一个标量场。在泊松重建中，$\mathbf{V}$ 是由点云的法线生成的向量场，$\rho$ 是点云的散度。</p><ol start=3><li><p><strong>构建八叉树</strong>：</p><ul><li>为了高效地求解泊松方程，使用八叉树（Octree）对点云进行分层表示。八叉树将空间递归地划分为八个子空间，直到达到指定的深度。</li></ul></li><li><p><strong>求解泊松方程</strong>：</p><ul><li>在八叉树的每个节点上，求解泊松方程。通过最小二乘法或其他数值方法，计算出每个节点的标量场值。</li></ul></li><li><p><strong>提取等值面</strong>：</p><ul><li>使用Marching Cubes算法从标量场中提取等值面，生成三角网格。等值面是标量场中具有相同值的点的集合。</li></ul></li><li><p><strong>平滑和优化</strong>：</p><ul><li>对生成的三角网格进行平滑和优化，以去除噪声和不规则性，生成最终的平滑表面。</li></ul></li></ol><h3 id=1122-代码示例>11.2.2 代码示例<a hidden class=anchor aria-hidden=true href=#1122-代码示例>#</a></h3><p>以下是使用Open3D库进行泊松重建的代码示例：</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>open3d</span> <span class=kn>as</span> <span class=nn>o3d</span>

<span class=c1># 读取点云</span>
<span class=n>pcd</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>io</span><span class=o>.</span><span class=n>read_point_cloud</span><span class=p>(</span><span class=s2>&#34;doll_1.ply&#34;</span><span class=p>)</span>

<span class=c1># 估计法线</span>
<span class=n>pcd</span><span class=o>.</span><span class=n>estimate_normals</span><span class=p>(</span><span class=n>search_param</span><span class=o>=</span><span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>KDTreeSearchParamHybrid</span><span class=p>(</span><span class=n>radius</span><span class=o>=</span><span class=mf>0.1</span><span class=p>,</span> <span class=n>max_nn</span><span class=o>=</span><span class=mi>30</span><span class=p>))</span>

<span class=c1># 泊松重建</span>
<span class=n>depth</span> <span class=o>=</span> <span class=mi>9</span>  <span class=c1># 调整深度参数</span>
<span class=n>mesh_poisson</span><span class=p>,</span> <span class=n>densities</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>TriangleMesh</span><span class=o>.</span><span class=n>create_from_point_cloud_poisson</span><span class=p>(</span><span class=n>pcd</span><span class=p>,</span> <span class=n>depth</span><span class=o>=</span><span class=n>depth</span><span class=p>)</span>

<span class=c1># 可视化泊松重建结果</span>
<span class=n>mesh_poisson</span><span class=o>.</span><span class=n>compute_vertex_normals</span><span class=p>()</span>
<span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>([</span><span class=n>mesh_poisson</span><span class=p>],</span> <span class=n>window_name</span><span class=o>=</span><span class=n>f</span><span class=s2>&#34;Poisson Reconstruction with depth={depth}&#34;</span><span class=p>)</span>
</code></pre></div><p><figure><img src=mesh_poisson_1.png alt=mesh_poisson_1 loading=lazy></figure></p><h3 id=1123-调整深度参数>11.2.3 调整深度参数<a hidden class=anchor aria-hidden=true href=#1123-调整深度参数>#</a></h3><p>通过调整深度参数，可以控制生成的网格的细节程度：</p><ul><li><strong>较小的深度值</strong>：生成的网格较粗糙，计算速度较快。</li><li><strong>较大的深度值</strong>：生成的网格较细致，计算速度较慢。</li></ul><h3 id=1124-总结>11.2.4 总结<a hidden class=anchor aria-hidden=true href=#1124-总结>#</a></h3><p>泊松重建是一种从点云数据生成平滑三角网格的有效方法。它通过求解泊松方程，能够处理噪声和不完整的点云数据，生成高质量的表面。通过调整深度参数，可以控制生成网格的细节程度。</p><h1 id=12--最小包围盒>12. 最小包围盒<a hidden class=anchor aria-hidden=true href=#12--最小包围盒>#</a></h1><p>使用Open3D计算点云的包围盒可以通过以下两种方式：轴对齐包围盒（Axis-Aligned Bounding Box, AABB）和有向包围盒（Oriented Bounding Box, OBB）。
下面是一个示例代码，展示如何计算和可视化这两种包围盒。</p><ul><li><strong>示例代码</strong></li></ul><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>open3d</span> <span class=kn>as</span> <span class=nn>o3d</span>

<span class=c1># 读取点云</span>
<span class=n>pcd</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>io</span><span class=o>.</span><span class=n>read_point_cloud</span><span class=p>(</span><span class=s2>&#34;doll_1.ply&#34;</span><span class=p>)</span>

<span class=c1># 计算轴对齐包围盒（AABB）</span>
<span class=n>aabb</span> <span class=o>=</span> <span class=n>pcd</span><span class=o>.</span><span class=n>get_axis_aligned_bounding_box</span><span class=p>()</span>

<span class=c1># 计算有向包围盒（OBB）</span>
<span class=n>obb</span> <span class=o>=</span> <span class=n>pcd</span><span class=o>.</span><span class=n>get_oriented_bounding_box</span><span class=p>()</span>

<span class=c1># 设置包围盒的颜色</span>
<span class=n>aabb</span><span class=o>.</span><span class=n>color</span> <span class=o>=</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>  <span class=c1># 红色</span>
<span class=n>obb</span><span class=o>.</span><span class=n>color</span> <span class=o>=</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>   <span class=c1># 绿色</span>

<span class=c1># 可视化点云和包围盒</span>
<span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>([</span><span class=n>pcd</span><span class=p>,</span> <span class=n>aabb</span><span class=p>,</span> <span class=n>obb</span><span class=p>],</span> <span class=n>window_name</span><span class=o>=</span><span class=s2>&#34;Bounding Boxes&#34;</span><span class=p>)</span>
</code></pre></div><p><figure><img src=aabb_obb.png alt=aabb_obb loading=lazy></figure></p><ul><li><strong>说明</strong></li></ul><ol><li><p><strong>读取点云</strong>：</p><ul><li>使用 <code>o3d.io.read_point_cloud</code> 函数读取点云数据。</li></ul></li><li><p><strong>计算轴对齐包围盒（AABB）</strong>：</p><ul><li>使用 <code>pcd.get_axis_aligned_bounding_box()</code> 方法计算点云的轴对齐包围盒。AABB是一个与坐标轴对齐的最小包围盒。</li></ul></li><li><p><strong>计算有向包围盒（OBB）</strong>：</p><ul><li>使用 <code>pcd.get_oriented_bounding_box()</code> 方法计算点云的有向包围盒。OBB是一个最小体积的包围盒，可以任意旋转。</li></ul></li><li><p><strong>设置包围盒的颜色</strong>：</p><ul><li>通过设置 <code>color</code> 属性来改变包围盒的颜色，以便在可视化时区分不同的包围盒。</li></ul></li><li><p><strong>可视化点云和包围盒</strong>：</p><ul><li>使用 <code>o3d.visualization.draw_geometries</code> 函数同时可视化点云和包围盒。</li></ul></li></ol><ul><li><strong>总结</strong></li></ul><p>通过上述代码，可以使用Open3D计算点云的轴对齐包围盒和有向包围盒，并进行可视化。这对于点云数据的分析和处理非常有用。</p><h1 id=13-凸包>13. 凸包<a hidden class=anchor aria-hidden=true href=#13-凸包>#</a></h1><p>使用Open3D计算点云的凸包可以通过 <code>compute_convex_hull</code> 方法来实现。
以下是一个示例代码，展示如何计算和可视化点云的凸包。</p><ul><li><strong>示例代码</strong></li></ul><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>open3d</span> <span class=kn>as</span> <span class=nn>o3d</span>

<span class=c1># 读取点云</span>
<span class=n>pcd</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>io</span><span class=o>.</span><span class=n>read_point_cloud</span><span class=p>(</span><span class=s2>&#34;doll_1.ply&#34;</span><span class=p>)</span>

<span class=c1># 计算凸包</span>
<span class=n>hull</span><span class=p>,</span> <span class=n>_</span> <span class=o>=</span> <span class=n>pcd</span><span class=o>.</span><span class=n>compute_convex_hull</span><span class=p>()</span>

<span class=c1># 设置凸包的颜色</span>
<span class=n>hull</span><span class=o>.</span><span class=n>paint_uniform_color</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>])</span>  <span class=c1># 红色</span>

<span class=c1># 可视化点云和凸包</span>
<span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>([</span><span class=n>pcd</span><span class=p>,</span> <span class=n>hull</span><span class=p>],</span> <span class=n>window_name</span><span class=o>=</span><span class=s2>&#34;Convex Hull&#34;</span><span class=p>)</span>
</code></pre></div><p><figure><img src=hull.png alt=hull loading=lazy></figure></p><ul><li><strong>说明</strong></li></ul><ol><li><p><strong>读取点云</strong>：</p><ul><li>使用 <code>o3d.io.read_point_cloud</code> 函数读取点云数据。</li></ul></li><li><p><strong>计算凸包</strong>：</p><ul><li>使用 <code>pcd.compute_convex_hull()</code> 方法计算点云的凸包。该方法返回一个三角网格表示的凸包和一个索引数组（这里我们只关心凸包）。</li></ul></li><li><p><strong>设置凸包的颜色</strong>：</p><ul><li>使用 <code>hull.paint_uniform_color([1, 0, 0])</code> 方法将凸包的颜色设置为红色，以便在可视化时区分凸包和点云。</li></ul></li><li><p><strong>可视化点云和凸包</strong>：</p><ul><li>使用 <code>o3d.visualization.draw_geometries</code> 函数同时可视化点云和凸包。</li></ul></li></ol><ul><li><p><strong>总结</strong></p><ul><li>通过上述代码，可以使用Open3D计算点云的凸包，并进行可视化。这对于点云数据的分析和处理非常有用，特别是在需要了解点云的外部形状时。</li></ul></li></ul><h1 id=14-体素化>14. 体素化<a hidden class=anchor aria-hidden=true href=#14-体素化>#</a></h1><p>使用Open3D计算点云的体素化可以通过 <code>voxel_down_sample</code> 方法来实现。体素化是将点云划分为固定大小的立方体（体素），并用每个体素内的点的中心点来代表该体素。
以下是一个示例代码，展示如何对点云进行体素化处理并进行可视化。</p><ul><li><strong>示例代码</strong></li></ul><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>open3d</span> <span class=kn>as</span> <span class=nn>o3d</span>

<span class=c1># 读取点云</span>
<span class=n>pcd</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>io</span><span class=o>.</span><span class=n>read_point_cloud</span><span class=p>(</span><span class=s2>&#34;doll_1.ply&#34;</span><span class=p>)</span>

<span class=c1># 设置体素大小</span>
<span class=n>voxel_size</span> <span class=o>=</span> <span class=mf>0.05</span>

<span class=c1># 进行体素化</span>
<span class=n>voxel_grid</span> <span class=o>=</span> <span class=n>o3d</span><span class=o>.</span><span class=n>geometry</span><span class=o>.</span><span class=n>VoxelGrid</span><span class=o>.</span><span class=n>create_from_point_cloud</span><span class=p>(</span><span class=n>pcd</span><span class=p>,</span> <span class=n>voxel_size</span><span class=o>=</span><span class=n>voxel_size</span><span class=p>)</span>

<span class=c1># 可视化原始点云和体素化后的点云</span>
<span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>([</span><span class=n>pcd</span><span class=p>],</span> <span class=n>window_name</span><span class=o>=</span><span class=s2>&#34;Original Point Cloud&#34;</span><span class=p>)</span>
<span class=n>o3d</span><span class=o>.</span><span class=n>visualization</span><span class=o>.</span><span class=n>draw_geometries</span><span class=p>([</span><span class=n>voxel_grid</span><span class=p>],</span> <span class=n>window_name</span><span class=o>=</span><span class=s2>&#34;Voxelized Point Cloud&#34;</span><span class=p>)</span>
</code></pre></div><p><figure><img src=voxel_grid_1.png alt=voxel_grid_1 loading=lazy></figure><figure><img src=voxel_grid_2.png alt=voxel_grid_2 loading=lazy></figure></p><ul><li><strong>说明</strong></li></ul><ol><li><p><strong>读取点云</strong>：</p><ul><li>使用 <code>o3d.io.read_point_cloud</code> 函数读取点云数据。</li></ul></li><li><p><strong>设置体素大小</strong>：</p><ul><li>定义体素的大小（例如 <code>voxel_size = 0.05</code>），该值决定了每个体素的边长。</li></ul></li><li><p><strong>进行体素化</strong>：</p><ul><li>使用 <code>o3d.geometry.VoxelGrid.create_from_point_cloud(pcd, voxel_size=voxel_size)</code> 方法对点云进行体素化处理。该方法返回一个 <code>VoxelGrid</code> 对象，表示体素化后的点云。</li></ul></li><li><p><strong>可视化原始点云和体素化后的点云</strong>：</p><ul><li>使用 <code>o3d.visualization.draw_geometries</code> 函数分别可视化原始点云和体素化后的点云。</li></ul></li></ol><ul><li><p><strong>总结</strong></p><ul><li>通过上述代码，可以使用Open3D对点云进行体素化处理，并进行可视化。体素化处理可以有效地减少点云数据的数量，同时保留点云的整体结构，对于点云数据的分析和处理非常有用。</li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://chase6305.github.io/tags/open3d/>Open3D</a></li></ul><nav class=paginav><a class=prev href=https://chase6305.github.io/posts/gui/qt/jetson/><span class=title>«</span><br><span>JetsonNV 上解决 PyQt5 “Could not load the Qt platform plugin ‘xcb‘“ 错误</span></a>
<a class=next href=https://chase6305.github.io/posts/dialout/dh/><span class=title>»</span><br><span>Python优化控制大寰PGC夹具的串口通信程序</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Open3D 教程学习指南 (持续整理) on x" href="https://x.com/intent/tweet/?text=Open3D%20%e6%95%99%e7%a8%8b%e5%ad%a6%e4%b9%a0%e6%8c%87%e5%8d%97%20%28%e6%8c%81%e7%bb%ad%e6%95%b4%e7%90%86%29&url=https%3a%2f%2fchase6305.github.io%2fposts%2fopen3d%2fintroduction%2f&hashtags=Open3D"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783H125.266L235.9 310.383 332.567 436.783H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z" /></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Open3D 教程学习指南 (持续整理) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fchase6305.github.io%2fposts%2fopen3d%2fintroduction%2f&title=Open3D%20%e6%95%99%e7%a8%8b%e5%ad%a6%e4%b9%a0%e6%8c%87%e5%8d%97%20%28%e6%8c%81%e7%bb%ad%e6%95%b4%e7%90%86%29&summary=Open3D%20%e6%95%99%e7%a8%8b%e5%ad%a6%e4%b9%a0%e6%8c%87%e5%8d%97%20%28%e6%8c%81%e7%bb%ad%e6%95%b4%e7%90%86%29&source=https%3a%2f%2fchase6305.github.io%2fposts%2fopen3d%2fintroduction%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0v-129.439c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02v-126.056c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768h75.024zm-307.552-334.556c-25.674.0-42.448 16.879-42.448 39.002.0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z" /></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Open3D 教程学习指南 (持续整理) on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fchase6305.github.io%2fposts%2fopen3d%2fintroduction%2f&title=Open3D%20%e6%95%99%e7%a8%8b%e5%ad%a6%e4%b9%a0%e6%8c%87%e5%8d%97%20%28%e6%8c%81%e7%bb%ad%e6%95%b4%e7%90%86%29"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zm-119.474 108.193c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zm-160.386-29.702c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z" /></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Open3D 教程学习指南 (持续整理) on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fchase6305.github.io%2fposts%2fopen3d%2fintroduction%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978v-192.915h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892z" /></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Open3D 教程学习指南 (持续整理) on whatsapp" href="https://api.whatsapp.com/send?text=Open3D%20%e6%95%99%e7%a8%8b%e5%ad%a6%e4%b9%a0%e6%8c%87%e5%8d%97%20%28%e6%8c%81%e7%bb%ad%e6%95%b4%e7%90%86%29%20-%20https%3a%2f%2fchase6305.github.io%2fposts%2fopen3d%2fintroduction%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23-13.314-11.876-22.304-26.542-24.916-31.026s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z" /></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Open3D 教程学习指南 (持续整理) on telegram" href="https://telegram.me/share/url?text=Open3D%20%e6%95%99%e7%a8%8b%e5%ad%a6%e4%b9%a0%e6%8c%87%e5%8d%97%20%28%e6%8c%81%e7%bb%ad%e6%95%b4%e7%90%86%29&url=https%3a%2f%2fchase6305.github.io%2fposts%2fopen3d%2fintroduction%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47A3.38 3.38.0 0126.49 29.86zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z" /></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Open3D 教程学习指南 (持续整理) on ycombinator" href="https://news.ycombinator.com/submitlink?t=Open3D%20%e6%95%99%e7%a8%8b%e5%ad%a6%e4%b9%a0%e6%8c%87%e5%8d%97%20%28%e6%8c%81%e7%bb%ad%e6%95%b4%e7%90%86%29&u=https%3a%2f%2fchase6305.github.io%2fposts%2fopen3d%2fintroduction%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" /></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://chase6305.github.io/>Chase Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z" /></svg></a><script>let menu=document.getElementById('menu')
if(menu){menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script><script>document.querySelectorAll('pre > code').forEach((codeblock)=>{const container=codeblock.parentNode.parentNode;const copybutton=document.createElement('button');copybutton.classList.add('copy-code');copybutton.innerHTML='copy';function copyingDone(){copybutton.innerHTML='copied!';setTimeout(()=>{copybutton.innerHTML='copy';},2000);}
copybutton.addEventListener('click',(cb)=>{if('clipboard'in navigator){navigator.clipboard.writeText(codeblock.textContent);copyingDone();return;}
const range=document.createRange();range.selectNodeContents(codeblock);const selection=window.getSelection();selection.removeAllRanges();selection.addRange(range);try{document.execCommand('copy');copyingDone();}catch(e){};selection.removeRange(range);});if(container.classList.contains("highlight")){container.appendChild(copybutton);}else if(container.parentNode.firstChild==container){}else if(codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"){codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);}else{codeblock.parentNode.appendChild(copybutton);}});</script></body></html>